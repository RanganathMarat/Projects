using System;
using System.Collections.Generic;
using System.IO;
using Common.Messages;
using RabbitMQ.Client;
using System.Threading;

namespace Common.Messaging
{
    /// <summary>
    /// Messaging
    /// </summary>
    public static class Messaging
    {
        private static readonly MessagingConfigurationSection Configuration;

        /// <summary>
        /// Initializes the <see cref="Messaging"/> class.
        /// </summary>
        static Messaging()
        {
            if (Configuration != null) return;

            Configuration = new MessagingConfigurationSection();
            Configuration.Initialize();
        }

        /// <summary>
        /// Proxy to the specified end point.
        /// </summary>
        /// <param name="endPoint">The end point.</param>
        /// <returns></returns>
        public static IMessaging Proxy(string endPoint)
        {
            if(!Configuration.Endpoints.ContainsKey(endPoint)) throw  new InvalidOperationException("Endpoint not found.");

            var endpoint =Configuration.Endpoints[endPoint];
            switch (endpoint.Topology)
            {
                case Topology.Basic:
                    if (string.IsNullOrEmpty(endpoint.Queue)) throw new InvalidOperationException("No Queue specified.");
                    return Basic(endpoint.Queue);
                case Topology.PubSub:
                    if (string.IsNullOrEmpty(endpoint.Exchange)) throw new InvalidOperationException("No Exchange specified.");
                    return PubSub(endpoint.Queue, endpoint.Exchange);
                case Topology.Routing:
                    if (string.IsNullOrEmpty(endpoint.Exchange)) throw new InvalidOperationException("No Exchange specified.");
                    if (string.IsNullOrEmpty(endpoint.Bindig)) throw new InvalidOperationException("No Bindig specified.");
                    return Routing(endpoint.Queue, endpoint.Exchange, endpoint.Bindig);
                case Topology.Topic:
                    if (string.IsNullOrEmpty(endpoint.Exchange)) throw new InvalidOperationException("No Exchange specified.");
                    if (string.IsNullOrEmpty(endpoint.Bindig)) throw new InvalidOperationException("No Bindig specified.");
                    return Topics(endpoint.Queue, endpoint.Exchange, endpoint.Bindig);
                case Topology.RPC:
                    if (string.IsNullOrEmpty(endpoint.Queue)) throw new InvalidOperationException("No Queue specified.");
                    if (string.IsNullOrEmpty(endpoint.Exchange)) throw new InvalidOperationException("No Exchange specified.");
                    return RPC(endpoint.Queue, endpoint.Exchange);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        /// <summary>
        /// Basics the specified queue.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <returns></returns>
        private static IMessaging Basic(string queue)
        {
            return new BasicMessage(queue);
        }

        /// <summary>
        /// Pubs the sub.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="exchange">The exchange.</param>
        /// <returns></returns>
        private static IMessaging PubSub(string queue, string exchange)
        {
            return new PubSubMessage(queue, exchange);
        }

        /// <summary>
        /// Routings the specified queue.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="exchange">The exchange.</param>
        /// <param name="keyWords">The key words.</param>
        /// <returns></returns>
        private static IMessaging Routing(string queue, string exchange, string keyWords)
        {
            return new RoutingMessage(queue, exchange, keyWords);
        }

        /// <summary>
        /// Topicses the specified queue.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="exchange">The exchange.</param>
        /// <param name="topicDescriptor">The topic descriptor.</param>
        /// <returns></returns>
        private static IMessaging Topics(string queue, string exchange, string topicDescriptor)
        {
            return new TopicsMessage(queue, exchange, topicDescriptor);
        }

        /// <summary>
        /// RPCs the specified server queue.
        /// </summary>
        /// <param name="serverQueue">The server queue.</param>
        /// <param name="responceQueue">The responce queue.</param>
        /// <returns></returns>
        private static IMessaging RPC(string serverQueue, string responceQueue)
        {
            return new RPCMessage(serverQueue, responceQueue);
        }


        /// <summary>
        /// Basic
        /// </summary>
        internal class BasicMessage : BaseMessage
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="BasicMessage"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            public BasicMessage(string queue)
                : base(queue, string.Empty, string.Empty)
            {
                ExchangeType = string.Empty;
            }

            /// <summary>
            /// Initializes a new instance of the <see cref="BasicMessage"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            /// <param name="exchange">The exchange.</param>
            /// <param name="bindings">The bindings.</param>
            protected BasicMessage(string queue, string exchange, string bindings)
                : base(queue, exchange, bindings)
            {
            }
        }

        /// <summary>
        /// PubSub
        /// </summary>
        internal class PubSubMessage : BasicMessage
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="PubSubMessage"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            /// <param name="exchange">The exchange.</param>
            public PubSubMessage(string queue, string exchange)
                : base(queue, exchange, string.Empty)
            {
                ExchangeType = RabbitMQ.Client.ExchangeType.Fanout;
            }
        }

        /// <summary>
        /// Routing
        /// </summary>
        internal class RoutingMessage : BasicMessage
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="RoutingMessage"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            /// <param name="exchange">The exchange.</param>
            /// <param name="keyWords">The comma separetd keywords.</param>
            public RoutingMessage(string queue, string exchange, string keyWords)
                : base(queue, exchange, keyWords)
            {
                ExchangeType = RabbitMQ.Client.ExchangeType.Direct;
            }
        }

        /// <summary>
        /// Topics
        /// </summary>
        internal class TopicsMessage : BasicMessage
        {
            /// <summary>
            /// Initializes a new instance of the <see cref="TopicsMessage"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            /// <param name="exchange">The exchange.</param>
            /// <param name="topicDescriptor">The dot separeted topic descriptor.</param>
            public TopicsMessage(string queue, string exchange, string topicDescriptor)
                : base(queue, exchange, topicDescriptor)
            {
                ExchangeType = RabbitMQ.Client.ExchangeType.Topic;
            }
        }

        /// <summary>
        /// RPC
        /// </summary>
        internal class RPCMessage : BasicMessage
        {
            /// <summary>
            /// Gets or sets the responce queue.
            /// </summary>
            /// <value>
            /// The responce queue.
            /// </value>
            public string ResponceQueue { get; private set; }

            /// <summary>
            /// Initializes a new instance of the <see cref="RPCMessage" /> class.
            /// </summary>
            /// <param name="serverQueue">The queue.</param>
            /// <param name="responceQueue">The responce queue.</param>
            public RPCMessage(string serverQueue, string responceQueue)
                : base(serverQueue)
            {
                ResponceQueue = responceQueue;
            }
        }

        /// <summary>
        /// MessageBase
        /// </summary>
        internal class BaseMessage : IConsume, IPublish, IMessaging
        {
            [Flags]
            private enum InstanceType
            {
                Consumer,
                Publisher
            }

            /// <summary>
            /// EventMaper
            /// </summary>
            /// <typeparam name="T"></typeparam>
            private class EventMaper<T> where T : MessageBase
            {
                /// <summary>
                /// The handler
                /// </summary>
                private readonly Action<T> _handler;

                /// <summary>
                /// Initializes a new instance of the <see cref="EventMaper{T}"/> class.
                /// </summary>
                /// <param name="handler">The handler.</param>
                public EventMaper(Action<T> handler)
                {
                    _handler = handler;
                }

                /// <summary>
                /// Gets the key.
                /// </summary>
                /// <value>
                /// The key.
                /// </value>
                public string Key { get { return typeof (T).ToString(); } }

                /// <summary>
                /// Gets the value.
                /// </summary>
                /// <value>
                /// The value.
                /// </value>
                public Action<MessageBase> Value{get{return Invoke;}}

                /// <summary>
                /// Invokes the specified message.
                /// </summary>
                /// <param name="message">The message.</param>
                private void Invoke(MessageBase message)
                {
                    _handler.Invoke((T) message);
                }
            }

            /// <summary>
            /// The message handlers
            /// </summary>
            private readonly Dictionary<string, Action<MessageBase>> _handlers;
            /// <summary>
            /// The _connection
            /// </summary>
            private IConnection _connection;
            /// <summary>
            /// The channel
            /// </summary>
            private IModel _channel;
            /// <summary>
            /// The _consumer
            /// </summary>
            private QueueingBasicConsumer _consumer;
            /// <summary>
            /// The _type
            /// </summary>
            private InstanceType _type;
            /// <summary>
            /// The _continue dequeue
            /// </summary>
            private long _continueDequeue;
            /// <summary>
            /// The host name
            /// </summary>
            private const string HostName = "localhost";
            /// <summary>
            /// Gets or sets the queue.
            /// </summary>
            /// <value>
            /// The queue.
            /// </value>
            protected string Queue { get; set; }
            /// <summary>
            /// Gets or sets the exchange.
            /// </summary>
            /// <value>
            /// The exchange.
            /// </value>
            protected string Exchange { get; set; }
            /// <summary>
            /// Gets or sets the type of the exchange.
            /// </summary>
            /// <value>
            /// The type of the exchange.
            /// </value>
            protected string ExchangeType { get; set; }
            /// <summary>
            /// Gets or sets the binding.
            /// </summary>
            /// <value>
            /// The binding.
            /// </value>
            protected string Bindings { get; set; }
            /// <summary>
            /// Gets the Consumer.
            /// </summary>
            /// <value>
            /// The consume.
            /// </value>
            public IConsume Consumer
            {
                get
                {
                    _type = InstanceType.Consumer;

                    var queueName = _channel.QueueDeclare(Queue, true, false, false, null);

                    if (!string.IsNullOrEmpty(Exchange))
                    {
                        _channel.ExchangeDeclare(Exchange, ExchangeType, true, false, null);
                        _channel.QueueBind(queueName, Exchange, Bindings);
                    }

                    _consumer = new QueueingBasicConsumer(_channel);
                    _channel.BasicConsume(queueName, true, _consumer);

                    return this;
                }
            }

            /// <summary>
            /// Gets the Publisher.
            /// </summary>
            /// <value>
            /// The publish.
            /// </value>
            public IPublish Publisher
            {
                get
                {
                    _type = InstanceType.Publisher;

                    if (!string.IsNullOrEmpty(Queue))
                    {
                        _channel.QueueDeclare(Queue, true, false, false, null);
                    }

                    if (!string.IsNullOrEmpty(Exchange))
                    {
                        _channel.ExchangeDeclare(Exchange, ExchangeType, true, false, null);
                    }

                    return this;
                }
            }

            /// <summary>
            /// Initializes a new instance of the <see cref="MessageBase"/> class.
            /// </summary>
            /// <param name="queue">The queue.</param>
            /// <param name="exchange">The exchange.</param>
            /// <param name="bindings">The bindings.</param>
            protected BaseMessage(string queue, string exchange, string bindings)
            {
                Queue = queue;
                Exchange = exchange;
                Bindings = bindings;
                _handlers = new Dictionary<string, Action<MessageBase>>();

                var factory = new ConnectionFactory { HostName = HostName };
                _connection = factory.CreateConnection();
                _channel = _connection.CreateModel();
            }

            /// <summary>
            /// Publishes the specified Messaging.
            /// </summary>
            /// <param name="message">The Messaging.</param>
            /// <exception cref="System.ArgumentNullException">Messaging;Invalid Messaging...</exception>
            /// <exception cref="System.InvalidOperationException">Is a comsumer instance!!</exception>
            void IPublish.Publish<T>(T message)
            {
                if (Equals(message,default(T))) throw new ArgumentNullException("message", "Invalid Messaging...");
                if (_type == InstanceType.Consumer) throw new InvalidOperationException("Is a comsumer instance!!");

                _channel.BasicPublish(Exchange, !string.IsNullOrEmpty(Exchange) ? Bindings : Queue, null, ToByte(message));
            }

            /// <summary>
            /// Object To byte[].
            /// </summary>
            /// <param name="message">The Messaging.</param>
            /// <returns></returns>
            private static byte[] ToByte<TMessage>(TMessage message)
            {
                using (MemoryStream bStream = new MemoryStream())
                {
                    ProtoBuf.Serializer.Serialize(bStream, message);
                    return bStream.ToArray();
                }
            }

            /// <summary>
            /// Froms byte[] to Object.
            /// </summary>
            /// <param name="body">The body.</param>
            /// <returns></returns>
            private static MessageBase FromByte(byte[] body)
            {
                using (MemoryStream bStream = new MemoryStream(body))
                {
                    return ProtoBuf.Serializer.Deserialize<MessageBase>(bStream);
                }
            }

            /// <summary>
            /// Dequeue the Messaging.
            /// </summary>
            /// <exception cref="System.ArgumentNullException">handler;Invalid handler...</exception>
            /// <exception cref="System.InvalidOperationException">Is a publisher instance!!</exception>
            void IConsume.DeQueue()
            {
                DeQueue(false);
            }

            /// <summary>
            /// Des the queue.
            /// </summary>
            /// <param name="purge">if set to <c>true</c> [purge].</param>
            /// <exception cref="System.InvalidOperationException">Is a publisher instance!!</exception>
            public void DeQueue(bool purge)
            {
                if (_type == InstanceType.Publisher) throw new InvalidOperationException("Is a publisher instance!!");
                if (purge) _channel.QueuePurge(Queue);
                Interlocked.Increment(ref _continueDequeue);

                Action startDequeue = () =>
                {
                    while (Interlocked.Read(ref _continueDequeue) != 0)
                    {
                        try
                        {
                            var e = _consumer.Queue.Dequeue();
                            HandleMessage(FromByte(e.Body));
                        }
                        catch (EndOfStreamException)
                        {
                            break;
                        }
                        // ReSharper disable EmptyGeneralCatchClause
                        catch (Exception)
                        // ReSharper restore EmptyGeneralCatchClause
                        {
                            // Log error.
                        }
                    }
                };

                startDequeue.BeginInvoke(null, null);
            }

            /// <summary>
            /// Registers the handler.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="handler">The handler.</param>
            /// <exception cref="System.ArgumentNullException">handler;Invalid handler...</exception>
            public void RegisterHandler<T>(Action<T> handler) where T : MessageBase
            {
                if (handler == null) throw new ArgumentNullException("handler", "Invalid handler...");

                EventMaper<T> maper = new EventMaper<T>(handler);

                var key = maper.Key;
                if (!_handlers.ContainsKey(key))
                {
                    _handlers.Add(key, maper.Value);
                }
            }

            /// <summary>
            /// Handles the message.
            /// </summary>
            /// <param name="message">The message.</param>
            private void HandleMessage(MessageBase message)
            {
                var key = message.TypeName;
                if (_handlers.ContainsKey(key))
                {
                    _handlers[key].Invoke(message);
                }
            }

            /// <summary>
            /// Stops dequeuing.
            /// </summary>
            void IConsume.Stop()
            {
                Interlocked.Exchange(ref _continueDequeue, 0);
            }

            /// <summary>
            /// Binds the queue to exchange.
            /// </summary>
            /// <param name="exchange">The exchange.</param>
            /// <param name="binding">The binding.</param>
            public void AddBinding(string exchange, string binding)
            {
                _channel.QueueBind(Queue, exchange, binding);
            }

            /// <summary>
            /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            /// </summary>
            public void Dispose()
            {
                Interlocked.Exchange(ref _continueDequeue, 0);

                if (_connection == null) return;

                _channel.Abort();
                _connection.Close();
                _handlers.Clear();
                _consumer = null;
                _channel = null;
                _connection = null;
            }
        }

    }

    /// <summary>
    /// IConsume
    /// </summary>
    public interface IConsume : IDisposable
    {
        /// <summary>
        /// Des the queue.
        /// </summary>
        void DeQueue();

        /// <summary>
        /// Des the queue.
        /// </summary>
        /// <param name="purge">if set to <c>true</c> [purge].</param>
        void DeQueue(bool purge);

        /// <summary>
        /// Registers the handler.
        /// </summary>
        /// <param name="handler">The handler.</param>
        void RegisterHandler<T>(Action<T> handler) where T:MessageBase;

        /// <summary>
        /// Stops dequeuing.
        /// </summary>
        void Stop();

        /// <summary>
        /// Binds the queue to exchange.
        /// </summary>
        /// <param name="exchange">The exchange.</param>
        /// <param name="binding">The binding.</param>
        void AddBinding(string exchange, string binding);
    }

    /// <summary>
    /// IPublish
    /// </summary>
    public interface IPublish : IDisposable
    {
        /// <summary>
        /// Publishes the specified Messaging.
        /// </summary>
        /// <param name="message">The Messaging.</param>
        void Publish<T>(T message) where T : MessageBase;
    }

    /// <summary>
    /// IMessaging
    /// </summary>
    public interface IMessaging
    {
        /// <summary>
        /// Gets the consumer.
        /// </summary>
        /// <value>
        /// The consumer.
        /// </value>
        IConsume Consumer { get; }

        /// <summary>
        /// Gets the publisher.
        /// </summary>
        /// <value>
        /// The publisher.
        /// </value>
        IPublish Publisher { get; }
    }
}
