// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ECViewmodel.proto

#ifndef PROTOBUF_ECViewmodel_2eproto__INCLUDED
#define PROTOBUF_ECViewmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ECViewmodel_2eproto();
void protobuf_AssignDesc_ECViewmodel_2eproto();
void protobuf_ShutdownFile_ECViewmodel_2eproto();

class CellInfoDTO;
class CipDTO;
class ConfirmReviewTypeDTO;
class DTOBase;
class ElementBase;
class ExamCardDTO;
class ExamCardPropertyDTO;
class GeometryDTO;
class IAdapter;
class Object;
class ScanSetDTO;
class SelectableItemDTO;
class StepDTO;
class TransferPropertyDTO;

enum SortAttributes {
  IMAGE_TYPE = 0,
  SLICE_NUMBER = 1,
  ECHO_NUMBER = 2,
  PHASE_NUMBER = 3,
  DYNAMIC_SCAN = 4,
  CHEMICAL_SHIFT = 5,
  DIFF_B_VALUE_NO = 6
};
bool SortAttributes_IsValid(int value);
const SortAttributes SortAttributes_MIN = IMAGE_TYPE;
const SortAttributes SortAttributes_MAX = DIFF_B_VALUE_NO;
const int SortAttributes_ARRAYSIZE = SortAttributes_MAX + 1;

const ::google::protobuf::EnumDescriptor* SortAttributes_descriptor();
inline const ::std::string& SortAttributes_Name(SortAttributes value) {
  return ::google::protobuf::internal::NameOfEnum(
    SortAttributes_descriptor(), value);
}
inline bool SortAttributes_Parse(
    const ::std::string& name, SortAttributes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortAttributes>(
    SortAttributes_descriptor(), name, value);
}
enum SortOrder {
  ASCENDING = 0,
  DESCENDING = 1
};
bool SortOrder_IsValid(int value);
const SortOrder SortOrder_MIN = ASCENDING;
const SortOrder SortOrder_MAX = DESCENDING;
const int SortOrder_ARRAYSIZE = SortOrder_MAX + 1;

const ::google::protobuf::EnumDescriptor* SortOrder_descriptor();
inline const ::std::string& SortOrder_Name(SortOrder value) {
  return ::google::protobuf::internal::NameOfEnum(
    SortOrder_descriptor(), value);
}
inline bool SortOrder_Parse(
    const ::std::string& name, SortOrder* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortOrder>(
    SortOrder_descriptor(), name, value);
}
// ===================================================================

class CellInfoDTO : public ::google::protobuf::Message {
 public:
  CellInfoDTO();
  virtual ~CellInfoDTO();

  CellInfoDTO(const CellInfoDTO& from);

  inline CellInfoDTO& operator=(const CellInfoDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellInfoDTO& default_instance();

  void Swap(CellInfoDTO* other);

  // implements Message ----------------------------------------------

  CellInfoDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellInfoDTO& from);
  void MergeFrom(const CellInfoDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool CanChange = 1 [default = false];
  inline bool has_canchange() const;
  inline void clear_canchange();
  static const int kCanChangeFieldNumber = 1;
  inline bool canchange() const;
  inline void set_canchange(bool value);

  // optional string Description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional .Object Value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::Object& value() const;
  inline ::Object* mutable_value();
  inline ::Object* release_value();
  inline void set_allocated_value(::Object* value);

  // @@protoc_insertion_point(class_scope:CellInfoDTO)
 private:
  inline void set_has_canchange();
  inline void clear_has_canchange();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  ::Object* value_;
  bool canchange_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static CellInfoDTO* default_instance_;
};
// -------------------------------------------------------------------

class CipDTO : public ::google::protobuf::Message {
 public:
  CipDTO();
  virtual ~CipDTO();

  CipDTO(const CipDTO& from);

  inline CipDTO& operator=(const CipDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CipDTO& default_instance();

  void Swap(CipDTO* other);

  // implements Message ----------------------------------------------

  CipDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CipDTO& from);
  void MergeFrom(const CipDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  inline void set_allocated_agent(::std::string* agent);

  // optional double Concentration = 2 [default = 0];
  inline bool has_concentration() const;
  inline void clear_concentration();
  static const int kConcentrationFieldNumber = 2;
  inline double concentration() const;
  inline void set_concentration(double value);

  // optional bool Confirmed = 3 [default = false];
  inline bool has_confirmed() const;
  inline void clear_confirmed();
  static const int kConfirmedFieldNumber = 3;
  inline bool confirmed() const;
  inline void set_confirmed(bool value);

  // optional bool Ignore = 4 [default = false];
  inline bool has_ignore() const;
  inline void clear_ignore();
  static const int kIgnoreFieldNumber = 4;
  inline bool ignore() const;
  inline void set_ignore(bool value);

  // optional uint32 InjectionStartDynamicNumber = 5 [default = 0];
  inline bool has_injectionstartdynamicnumber() const;
  inline void clear_injectionstartdynamicnumber();
  static const int kInjectionStartDynamicNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 injectionstartdynamicnumber() const;
  inline void set_injectionstartdynamicnumber(::google::protobuf::uint32 value);

  // optional bool Manual = 6 [default = false];
  inline bool has_manual() const;
  inline void clear_manual();
  static const int kManualFieldNumber = 6;
  inline bool manual() const;
  inline void set_manual(bool value);

  // optional string RouteOfAdministration = 7;
  inline bool has_routeofadministration() const;
  inline void clear_routeofadministration();
  static const int kRouteOfAdministrationFieldNumber = 7;
  inline const ::std::string& routeofadministration() const;
  inline void set_routeofadministration(const ::std::string& value);
  inline void set_routeofadministration(const char* value);
  inline void set_routeofadministration(const char* value, size_t size);
  inline ::std::string* mutable_routeofadministration();
  inline ::std::string* release_routeofadministration();
  inline void set_allocated_routeofadministration(::std::string* routeofadministration);

  // optional double Volume = 8 [default = 0];
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 8;
  inline double volume() const;
  inline void set_volume(double value);

  // @@protoc_insertion_point(class_scope:CipDTO)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_concentration();
  inline void clear_has_concentration();
  inline void set_has_confirmed();
  inline void clear_has_confirmed();
  inline void set_has_ignore();
  inline void clear_has_ignore();
  inline void set_has_injectionstartdynamicnumber();
  inline void clear_has_injectionstartdynamicnumber();
  inline void set_has_manual();
  inline void clear_has_manual();
  inline void set_has_routeofadministration();
  inline void clear_has_routeofadministration();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agent_;
  double concentration_;
  bool confirmed_;
  bool ignore_;
  bool manual_;
  ::google::protobuf::uint32 injectionstartdynamicnumber_;
  ::std::string* routeofadministration_;
  double volume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static CipDTO* default_instance_;
};
// -------------------------------------------------------------------

class ConfirmReviewTypeDTO : public ::google::protobuf::Message {
 public:
  ConfirmReviewTypeDTO();
  virtual ~ConfirmReviewTypeDTO();

  ConfirmReviewTypeDTO(const ConfirmReviewTypeDTO& from);

  inline ConfirmReviewTypeDTO& operator=(const ConfirmReviewTypeDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfirmReviewTypeDTO& default_instance();

  void Swap(ConfirmReviewTypeDTO* other);

  // implements Message ----------------------------------------------

  ConfirmReviewTypeDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfirmReviewTypeDTO& from);
  void MergeFrom(const ConfirmReviewTypeDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:ConfirmReviewTypeDTO)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static ConfirmReviewTypeDTO* default_instance_;
};
// -------------------------------------------------------------------

class DTOBase : public ::google::protobuf::Message {
 public:
  DTOBase();
  virtual ~DTOBase();

  DTOBase(const DTOBase& from);

  inline DTOBase& operator=(const DTOBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DTOBase& default_instance();

  void Swap(DTOBase* other);

  // implements Message ----------------------------------------------

  DTOBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DTOBase& from);
  void MergeFrom(const DTOBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .IAdapter Adapter = 1;
  inline bool has_adapter() const;
  inline void clear_adapter();
  static const int kAdapterFieldNumber = 1;
  inline const ::IAdapter& adapter() const;
  inline ::IAdapter* mutable_adapter();
  inline ::IAdapter* release_adapter();
  inline void set_allocated_adapter(::IAdapter* adapter);

  // repeated .Object Tag = 2;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::Object& tag(int index) const;
  inline ::Object* mutable_tag(int index);
  inline ::Object* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::Object >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::Object >*
      mutable_tag();

  // optional bool Validation = 3 [default = false];
  inline bool has_validation() const;
  inline void clear_validation();
  static const int kValidationFieldNumber = 3;
  inline bool validation() const;
  inline void set_validation(bool value);

  // optional .CellInfoDTO CellInfoDTO = 10;
  inline bool has_cellinfodto() const;
  inline void clear_cellinfodto();
  static const int kCellInfoDTOFieldNumber = 10;
  inline const ::CellInfoDTO& cellinfodto() const;
  inline ::CellInfoDTO* mutable_cellinfodto();
  inline ::CellInfoDTO* release_cellinfodto();
  inline void set_allocated_cellinfodto(::CellInfoDTO* cellinfodto);

  // optional .CipDTO CipDTO = 20;
  inline bool has_cipdto() const;
  inline void clear_cipdto();
  static const int kCipDTOFieldNumber = 20;
  inline const ::CipDTO& cipdto() const;
  inline ::CipDTO* mutable_cipdto();
  inline ::CipDTO* release_cipdto();
  inline void set_allocated_cipdto(::CipDTO* cipdto);

  // optional .ConfirmReviewTypeDTO ConfirmReviewTypeDTO = 30;
  inline bool has_confirmreviewtypedto() const;
  inline void clear_confirmreviewtypedto();
  static const int kConfirmReviewTypeDTOFieldNumber = 30;
  inline const ::ConfirmReviewTypeDTO& confirmreviewtypedto() const;
  inline ::ConfirmReviewTypeDTO* mutable_confirmreviewtypedto();
  inline ::ConfirmReviewTypeDTO* release_confirmreviewtypedto();
  inline void set_allocated_confirmreviewtypedto(::ConfirmReviewTypeDTO* confirmreviewtypedto);

  // optional .ExamCardPropertyDTO ExamCardPropertyDTO = 40;
  inline bool has_examcardpropertydto() const;
  inline void clear_examcardpropertydto();
  static const int kExamCardPropertyDTOFieldNumber = 40;
  inline const ::ExamCardPropertyDTO& examcardpropertydto() const;
  inline ::ExamCardPropertyDTO* mutable_examcardpropertydto();
  inline ::ExamCardPropertyDTO* release_examcardpropertydto();
  inline void set_allocated_examcardpropertydto(::ExamCardPropertyDTO* examcardpropertydto);

  // optional .SelectableItemDTO SelectableItemDTO = 50;
  inline bool has_selectableitemdto() const;
  inline void clear_selectableitemdto();
  static const int kSelectableItemDTOFieldNumber = 50;
  inline const ::SelectableItemDTO& selectableitemdto() const;
  inline ::SelectableItemDTO* mutable_selectableitemdto();
  inline ::SelectableItemDTO* release_selectableitemdto();
  inline void set_allocated_selectableitemdto(::SelectableItemDTO* selectableitemdto);

  // optional .TransferPropertyDTO TransferPropertyDTO = 60;
  inline bool has_transferpropertydto() const;
  inline void clear_transferpropertydto();
  static const int kTransferPropertyDTOFieldNumber = 60;
  inline const ::TransferPropertyDTO& transferpropertydto() const;
  inline ::TransferPropertyDTO* mutable_transferpropertydto();
  inline ::TransferPropertyDTO* release_transferpropertydto();
  inline void set_allocated_transferpropertydto(::TransferPropertyDTO* transferpropertydto);

  // @@protoc_insertion_point(class_scope:DTOBase)
 private:
  inline void set_has_adapter();
  inline void clear_has_adapter();
  inline void set_has_validation();
  inline void clear_has_validation();
  inline void set_has_cellinfodto();
  inline void clear_has_cellinfodto();
  inline void set_has_cipdto();
  inline void clear_has_cipdto();
  inline void set_has_confirmreviewtypedto();
  inline void clear_has_confirmreviewtypedto();
  inline void set_has_examcardpropertydto();
  inline void clear_has_examcardpropertydto();
  inline void set_has_selectableitemdto();
  inline void clear_has_selectableitemdto();
  inline void set_has_transferpropertydto();
  inline void clear_has_transferpropertydto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::IAdapter* adapter_;
  ::google::protobuf::RepeatedPtrField< ::Object > tag_;
  ::CellInfoDTO* cellinfodto_;
  ::CipDTO* cipdto_;
  ::ConfirmReviewTypeDTO* confirmreviewtypedto_;
  ::ExamCardPropertyDTO* examcardpropertydto_;
  ::SelectableItemDTO* selectableitemdto_;
  ::TransferPropertyDTO* transferpropertydto_;
  bool validation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static DTOBase* default_instance_;
};
// -------------------------------------------------------------------

class ElementBase : public ::google::protobuf::Message {
 public:
  ElementBase();
  virtual ~ElementBase();

  ElementBase(const ElementBase& from);

  inline ElementBase& operator=(const ElementBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementBase& default_instance();

  void Swap(ElementBase* other);

  // implements Message ----------------------------------------------

  ElementBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElementBase& from);
  void MergeFrom(const ElementBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ElementBase ChildElements = 1;
  inline int childelements_size() const;
  inline void clear_childelements();
  static const int kChildElementsFieldNumber = 1;
  inline const ::ElementBase& childelements(int index) const;
  inline ::ElementBase* mutable_childelements(int index);
  inline ::ElementBase* add_childelements();
  inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
      childelements() const;
  inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
      mutable_childelements();

  // optional bool Enabled = 2 [default = false];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool Expanded = 3 [default = false];
  inline bool has_expanded() const;
  inline void clear_expanded();
  static const int kExpandedFieldNumber = 3;
  inline bool expanded() const;
  inline void set_expanded(bool value);

  // optional bool Invisible = 4 [default = false];
  inline bool has_invisible() const;
  inline void clear_invisible();
  static const int kInvisibleFieldNumber = 4;
  inline bool invisible() const;
  inline void set_invisible(bool value);

  // optional .ElementBase Parent = 5;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 5;
  inline const ::ElementBase& parent() const;
  inline ::ElementBase* mutable_parent();
  inline ::ElementBase* release_parent();
  inline void set_allocated_parent(::ElementBase* parent);

  // optional bool Selected = 6 [default = false];
  inline bool has_selected() const;
  inline void clear_selected();
  static const int kSelectedFieldNumber = 6;
  inline bool selected() const;
  inline void set_selected(bool value);

  // optional .ExamCardDTO ExamCardDTO = 100;
  inline bool has_examcarddto() const;
  inline void clear_examcarddto();
  static const int kExamCardDTOFieldNumber = 100;
  inline const ::ExamCardDTO& examcarddto() const;
  inline ::ExamCardDTO* mutable_examcarddto();
  inline ::ExamCardDTO* release_examcarddto();
  inline void set_allocated_examcarddto(::ExamCardDTO* examcarddto);

  // optional .StepDTO StepDTO = 200;
  inline bool has_stepdto() const;
  inline void clear_stepdto();
  static const int kStepDTOFieldNumber = 200;
  inline const ::StepDTO& stepdto() const;
  inline ::StepDTO* mutable_stepdto();
  inline ::StepDTO* release_stepdto();
  inline void set_allocated_stepdto(::StepDTO* stepdto);

  // optional .ScanSetDTO ScanSetDTO = 300;
  inline bool has_scansetdto() const;
  inline void clear_scansetdto();
  static const int kScanSetDTOFieldNumber = 300;
  inline const ::ScanSetDTO& scansetdto() const;
  inline ::ScanSetDTO* mutable_scansetdto();
  inline ::ScanSetDTO* release_scansetdto();
  inline void set_allocated_scansetdto(::ScanSetDTO* scansetdto);

  // @@protoc_insertion_point(class_scope:ElementBase)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_expanded();
  inline void clear_has_expanded();
  inline void set_has_invisible();
  inline void clear_has_invisible();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_selected();
  inline void clear_has_selected();
  inline void set_has_examcarddto();
  inline void clear_has_examcarddto();
  inline void set_has_stepdto();
  inline void clear_has_stepdto();
  inline void set_has_scansetdto();
  inline void clear_has_scansetdto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ElementBase > childelements_;
  ::ElementBase* parent_;
  ::ExamCardDTO* examcarddto_;
  ::StepDTO* stepdto_;
  ::ScanSetDTO* scansetdto_;
  bool enabled_;
  bool expanded_;
  bool invisible_;
  bool selected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static ElementBase* default_instance_;
};
// -------------------------------------------------------------------

class ExamCardDTO : public ::google::protobuf::Message {
 public:
  ExamCardDTO();
  virtual ~ExamCardDTO();

  ExamCardDTO(const ExamCardDTO& from);

  inline ExamCardDTO& operator=(const ExamCardDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExamCardDTO& default_instance();

  void Swap(ExamCardDTO* other);

  // implements Message ----------------------------------------------

  ExamCardDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExamCardDTO& from);
  void MergeFrom(const ExamCardDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ElementBase ChildElements = 1;
  inline int childelements_size() const;
  inline void clear_childelements();
  static const int kChildElementsFieldNumber = 1;
  inline const ::ElementBase& childelements(int index) const;
  inline ::ElementBase* mutable_childelements(int index);
  inline ::ElementBase* add_childelements();
  inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
      childelements() const;
  inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
      mutable_childelements();

  // optional string ExamCardDescription = 2;
  inline bool has_examcarddescription() const;
  inline void clear_examcarddescription();
  static const int kExamCardDescriptionFieldNumber = 2;
  inline const ::std::string& examcarddescription() const;
  inline void set_examcarddescription(const ::std::string& value);
  inline void set_examcarddescription(const char* value);
  inline void set_examcarddescription(const char* value, size_t size);
  inline ::std::string* mutable_examcarddescription();
  inline ::std::string* release_examcarddescription();
  inline void set_allocated_examcarddescription(::std::string* examcarddescription);

  // optional .DTOBase ExamCardProperty = 3;
  inline bool has_examcardproperty() const;
  inline void clear_examcardproperty();
  static const int kExamCardPropertyFieldNumber = 3;
  inline const ::DTOBase& examcardproperty() const;
  inline ::DTOBase* mutable_examcardproperty();
  inline ::DTOBase* release_examcardproperty();
  inline void set_allocated_examcardproperty(::DTOBase* examcardproperty);

  // optional string Name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ExamCardDTO)
 private:
  inline void set_has_examcarddescription();
  inline void clear_has_examcarddescription();
  inline void set_has_examcardproperty();
  inline void clear_has_examcardproperty();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ElementBase > childelements_;
  ::std::string* examcarddescription_;
  ::DTOBase* examcardproperty_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static ExamCardDTO* default_instance_;
};
// -------------------------------------------------------------------

class ExamCardPropertyDTO : public ::google::protobuf::Message {
 public:
  ExamCardPropertyDTO();
  virtual ~ExamCardPropertyDTO();

  ExamCardPropertyDTO(const ExamCardPropertyDTO& from);

  inline ExamCardPropertyDTO& operator=(const ExamCardPropertyDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExamCardPropertyDTO& default_instance();

  void Swap(ExamCardPropertyDTO* other);

  // implements Message ----------------------------------------------

  ExamCardPropertyDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExamCardPropertyDTO& from);
  void MergeFrom(const ExamCardPropertyDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float AlignOverlap = 1 [default = 0];
  inline bool has_alignoverlap() const;
  inline void clear_alignoverlap();
  static const int kAlignOverlapFieldNumber = 1;
  inline float alignoverlap() const;
  inline void set_alignoverlap(float value);

  // optional string AnatomicRegion = 2;
  inline bool has_anatomicregion() const;
  inline void clear_anatomicregion();
  static const int kAnatomicRegionFieldNumber = 2;
  inline const ::std::string& anatomicregion() const;
  inline void set_anatomicregion(const ::std::string& value);
  inline void set_anatomicregion(const char* value);
  inline void set_anatomicregion(const char* value, size_t size);
  inline ::std::string* mutable_anatomicregion();
  inline ::std::string* release_anatomicregion();
  inline void set_allocated_anatomicregion(::std::string* anatomicregion);

  // repeated string AnatomicRegionsList = 3;
  inline int anatomicregionslist_size() const;
  inline void clear_anatomicregionslist();
  static const int kAnatomicRegionsListFieldNumber = 3;
  inline const ::std::string& anatomicregionslist(int index) const;
  inline ::std::string* mutable_anatomicregionslist(int index);
  inline void set_anatomicregionslist(int index, const ::std::string& value);
  inline void set_anatomicregionslist(int index, const char* value);
  inline void set_anatomicregionslist(int index, const char* value, size_t size);
  inline ::std::string* add_anatomicregionslist();
  inline void add_anatomicregionslist(const ::std::string& value);
  inline void add_anatomicregionslist(const char* value);
  inline void add_anatomicregionslist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& anatomicregionslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_anatomicregionslist();

  // repeated string AnatomiesList = 4;
  inline int anatomieslist_size() const;
  inline void clear_anatomieslist();
  static const int kAnatomiesListFieldNumber = 4;
  inline const ::std::string& anatomieslist(int index) const;
  inline ::std::string* mutable_anatomieslist(int index);
  inline void set_anatomieslist(int index, const ::std::string& value);
  inline void set_anatomieslist(int index, const char* value);
  inline void set_anatomieslist(int index, const char* value, size_t size);
  inline ::std::string* add_anatomieslist();
  inline void add_anatomieslist(const ::std::string& value);
  inline void add_anatomieslist(const char* value);
  inline void add_anatomieslist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& anatomieslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_anatomieslist();

  // optional string Anatomy = 5;
  inline bool has_anatomy() const;
  inline void clear_anatomy();
  static const int kAnatomyFieldNumber = 5;
  inline const ::std::string& anatomy() const;
  inline void set_anatomy(const ::std::string& value);
  inline void set_anatomy(const char* value);
  inline void set_anatomy(const char* value, size_t size);
  inline ::std::string* mutable_anatomy();
  inline ::std::string* release_anatomy();
  inline void set_allocated_anatomy(::std::string* anatomy);

  // optional bool AutoFillInHeartRate = 6 [default = false];
  inline bool has_autofillinheartrate() const;
  inline void clear_autofillinheartrate();
  static const int kAutoFillInHeartRateFieldNumber = 6;
  inline bool autofillinheartrate() const;
  inline void set_autofillinheartrate(bool value);

  // optional bool AutoFillInHeartRateAllowed = 7 [default = false];
  inline bool has_autofillinheartrateallowed() const;
  inline void clear_autofillinheartrateallowed();
  static const int kAutoFillInHeartRateAllowedFieldNumber = 7;
  inline bool autofillinheartrateallowed() const;
  inline void set_autofillinheartrateallowed(bool value);

  // repeated .DTOBase ConfiguredCoils = 8;
  inline int configuredcoils_size() const;
  inline void clear_configuredcoils();
  static const int kConfiguredCoilsFieldNumber = 8;
  inline const ::DTOBase& configuredcoils(int index) const;
  inline ::DTOBase* mutable_configuredcoils(int index);
  inline ::DTOBase* add_configuredcoils();
  inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
      configuredcoils() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
      mutable_configuredcoils();

  // optional string DockingMode = 9;
  inline bool has_dockingmode() const;
  inline void clear_dockingmode();
  static const int kDockingModeFieldNumber = 9;
  inline const ::std::string& dockingmode() const;
  inline void set_dockingmode(const ::std::string& value);
  inline void set_dockingmode(const char* value);
  inline void set_dockingmode(const char* value, size_t size);
  inline ::std::string* mutable_dockingmode();
  inline ::std::string* release_dockingmode();
  inline void set_allocated_dockingmode(::std::string* dockingmode);

  // optional int32 ExamDuration = 10 [default = 0];
  inline bool has_examduration() const;
  inline void clear_examduration();
  static const int kExamDurationFieldNumber = 10;
  inline ::google::protobuf::int32 examduration() const;
  inline void set_examduration(::google::protobuf::int32 value);

  // optional bool GeoLinkPropagation = 11 [default = false];
  inline bool has_geolinkpropagation() const;
  inline void clear_geolinkpropagation();
  static const int kGeoLinkPropagationFieldNumber = 11;
  inline bool geolinkpropagation() const;
  inline void set_geolinkpropagation(bool value);

  // optional int32 HeartRate = 12 [default = 0];
  inline bool has_heartrate() const;
  inline void clear_heartrate();
  static const int kHeartRateFieldNumber = 12;
  inline ::google::protobuf::int32 heartrate() const;
  inline void set_heartrate(::google::protobuf::int32 value);

  // repeated .DTOBase Lateralities = 13;
  inline int lateralities_size() const;
  inline void clear_lateralities();
  static const int kLateralitiesFieldNumber = 13;
  inline const ::DTOBase& lateralities(int index) const;
  inline ::DTOBase* mutable_lateralities(int index);
  inline ::DTOBase* add_lateralities();
  inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
      lateralities() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
      mutable_lateralities();

  // optional string Laterality = 14;
  inline bool has_laterality() const;
  inline void clear_laterality();
  static const int kLateralityFieldNumber = 14;
  inline const ::std::string& laterality() const;
  inline void set_laterality(const ::std::string& value);
  inline void set_laterality(const char* value);
  inline void set_laterality(const char* value, size_t size);
  inline ::std::string* mutable_laterality();
  inline ::std::string* release_laterality();
  inline void set_allocated_laterality(::std::string* laterality);

  // optional bool LateralityConflict = 15 [default = false];
  inline bool has_lateralityconflict() const;
  inline void clear_lateralityconflict();
  static const int kLateralityConflictFieldNumber = 15;
  inline bool lateralityconflict() const;
  inline void set_lateralityconflict(bool value);

  // optional string Name = 16;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 16;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .GeometryDTO NamedGeometries = 17;
  inline int namedgeometries_size() const;
  inline void clear_namedgeometries();
  static const int kNamedGeometriesFieldNumber = 17;
  inline const ::GeometryDTO& namedgeometries(int index) const;
  inline ::GeometryDTO* mutable_namedgeometries(int index);
  inline ::GeometryDTO* add_namedgeometries();
  inline const ::google::protobuf::RepeatedPtrField< ::GeometryDTO >&
      namedgeometries() const;
  inline ::google::protobuf::RepeatedPtrField< ::GeometryDTO >*
      mutable_namedgeometries();

  // optional bool Paediatric = 18 [default = false];
  inline bool has_paediatric() const;
  inline void clear_paediatric();
  static const int kPaediatricFieldNumber = 18;
  inline bool paediatric() const;
  inline void set_paediatric(bool value);

  // repeated .DTOBase PatientOrientation = 19;
  inline int patientorientation_size() const;
  inline void clear_patientorientation();
  static const int kPatientOrientationFieldNumber = 19;
  inline const ::DTOBase& patientorientation(int index) const;
  inline ::DTOBase* mutable_patientorientation(int index);
  inline ::DTOBase* add_patientorientation();
  inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
      patientorientation() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
      mutable_patientorientation();

  // optional double PatientWeight = 20 [default = 0];
  inline bool has_patientweight() const;
  inline void clear_patientweight();
  static const int kPatientWeightFieldNumber = 20;
  inline double patientweight() const;
  inline void set_patientweight(double value);

  // optional bool PosteriorHoldBack = 21 [default = false];
  inline bool has_posteriorholdback() const;
  inline void clear_posteriorholdback();
  static const int kPosteriorHoldBackFieldNumber = 21;
  inline bool posteriorholdback() const;
  inline void set_posteriorholdback(bool value);

  // optional double PredictedSED = 22 [default = 0];
  inline bool has_predictedsed() const;
  inline void clear_predictedsed();
  static const int kPredictedSEDFieldNumber = 22;
  inline double predictedsed() const;
  inline void set_predictedsed(double value);

  // repeated .DTOBase ReviewRequired = 23;
  inline int reviewrequired_size() const;
  inline void clear_reviewrequired();
  static const int kReviewRequiredFieldNumber = 23;
  inline const ::DTOBase& reviewrequired(int index) const;
  inline ::DTOBase* mutable_reviewrequired(int index);
  inline ::DTOBase* add_reviewrequired();
  inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
      reviewrequired() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
      mutable_reviewrequired();

  // optional bool SmartType = 24 [default = false];
  inline bool has_smarttype() const;
  inline void clear_smarttype();
  static const int kSmartTypeFieldNumber = 24;
  inline bool smarttype() const;
  inline void set_smarttype(bool value);

  // optional bool TableUsage = 25 [default = false];
  inline bool has_tableusage() const;
  inline void clear_tableusage();
  static const int kTableUsageFieldNumber = 25;
  inline bool tableusage() const;
  inline void set_tableusage(bool value);

  // optional string WeightUnit = 26;
  inline bool has_weightunit() const;
  inline void clear_weightunit();
  static const int kWeightUnitFieldNumber = 26;
  inline const ::std::string& weightunit() const;
  inline void set_weightunit(const ::std::string& value);
  inline void set_weightunit(const char* value);
  inline void set_weightunit(const char* value, size_t size);
  inline ::std::string* mutable_weightunit();
  inline ::std::string* release_weightunit();
  inline void set_allocated_weightunit(::std::string* weightunit);

  // @@protoc_insertion_point(class_scope:ExamCardPropertyDTO)
 private:
  inline void set_has_alignoverlap();
  inline void clear_has_alignoverlap();
  inline void set_has_anatomicregion();
  inline void clear_has_anatomicregion();
  inline void set_has_anatomy();
  inline void clear_has_anatomy();
  inline void set_has_autofillinheartrate();
  inline void clear_has_autofillinheartrate();
  inline void set_has_autofillinheartrateallowed();
  inline void clear_has_autofillinheartrateallowed();
  inline void set_has_dockingmode();
  inline void clear_has_dockingmode();
  inline void set_has_examduration();
  inline void clear_has_examduration();
  inline void set_has_geolinkpropagation();
  inline void clear_has_geolinkpropagation();
  inline void set_has_heartrate();
  inline void clear_has_heartrate();
  inline void set_has_laterality();
  inline void clear_has_laterality();
  inline void set_has_lateralityconflict();
  inline void clear_has_lateralityconflict();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_paediatric();
  inline void clear_has_paediatric();
  inline void set_has_patientweight();
  inline void clear_has_patientweight();
  inline void set_has_posteriorholdback();
  inline void clear_has_posteriorholdback();
  inline void set_has_predictedsed();
  inline void clear_has_predictedsed();
  inline void set_has_smarttype();
  inline void clear_has_smarttype();
  inline void set_has_tableusage();
  inline void clear_has_tableusage();
  inline void set_has_weightunit();
  inline void clear_has_weightunit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* anatomicregion_;
  ::google::protobuf::RepeatedPtrField< ::std::string> anatomicregionslist_;
  ::google::protobuf::RepeatedPtrField< ::std::string> anatomieslist_;
  ::std::string* anatomy_;
  ::google::protobuf::RepeatedPtrField< ::DTOBase > configuredcoils_;
  float alignoverlap_;
  bool autofillinheartrate_;
  bool autofillinheartrateallowed_;
  bool geolinkpropagation_;
  bool lateralityconflict_;
  ::std::string* dockingmode_;
  ::google::protobuf::int32 examduration_;
  ::google::protobuf::int32 heartrate_;
  ::google::protobuf::RepeatedPtrField< ::DTOBase > lateralities_;
  ::std::string* laterality_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::GeometryDTO > namedgeometries_;
  ::google::protobuf::RepeatedPtrField< ::DTOBase > patientorientation_;
  double patientweight_;
  double predictedsed_;
  ::google::protobuf::RepeatedPtrField< ::DTOBase > reviewrequired_;
  ::std::string* weightunit_;
  bool paediatric_;
  bool posteriorholdback_;
  bool smarttype_;
  bool tableusage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static ExamCardPropertyDTO* default_instance_;
};
// -------------------------------------------------------------------

class GeometryDTO : public ::google::protobuf::Message {
 public:
  GeometryDTO();
  virtual ~GeometryDTO();

  GeometryDTO(const GeometryDTO& from);

  inline GeometryDTO& operator=(const GeometryDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeometryDTO& default_instance();

  void Swap(GeometryDTO* other);

  // implements Message ----------------------------------------------

  GeometryDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeometryDTO& from);
  void MergeFrom(const GeometryDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GeometryDTO)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static GeometryDTO* default_instance_;
};
// -------------------------------------------------------------------

class IAdapter : public ::google::protobuf::Message {
 public:
  IAdapter();
  virtual ~IAdapter();

  IAdapter(const IAdapter& from);

  inline IAdapter& operator=(const IAdapter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IAdapter& default_instance();

  void Swap(IAdapter* other);

  // implements Message ----------------------------------------------

  IAdapter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IAdapter& from);
  void MergeFrom(const IAdapter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IAdapter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static IAdapter* default_instance_;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Object)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// -------------------------------------------------------------------

class ScanSetDTO : public ::google::protobuf::Message {
 public:
  ScanSetDTO();
  virtual ~ScanSetDTO();

  ScanSetDTO(const ScanSetDTO& from);

  inline ScanSetDTO& operator=(const ScanSetDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanSetDTO& default_instance();

  void Swap(ScanSetDTO* other);

  // implements Message ----------------------------------------------

  ScanSetDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanSetDTO& from);
  void MergeFrom(const ScanSetDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ElementBase ChildElements = 1;
  inline int childelements_size() const;
  inline void clear_childelements();
  static const int kChildElementsFieldNumber = 1;
  inline const ::ElementBase& childelements(int index) const;
  inline ::ElementBase* mutable_childelements(int index);
  inline ::ElementBase* add_childelements();
  inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
      childelements() const;
  inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
      mutable_childelements();

  // optional bool EditMode = 2 [default = false];
  inline bool has_editmode() const;
  inline void clear_editmode();
  static const int kEditModeFieldNumber = 2;
  inline bool editmode() const;
  inline void set_editmode(bool value);

  // @@protoc_insertion_point(class_scope:ScanSetDTO)
 private:
  inline void set_has_editmode();
  inline void clear_has_editmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ElementBase > childelements_;
  bool editmode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static ScanSetDTO* default_instance_;
};
// -------------------------------------------------------------------

class SelectableItemDTO : public ::google::protobuf::Message {
 public:
  SelectableItemDTO();
  virtual ~SelectableItemDTO();

  SelectableItemDTO(const SelectableItemDTO& from);

  inline SelectableItemDTO& operator=(const SelectableItemDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectableItemDTO& default_instance();

  void Swap(SelectableItemDTO* other);

  // implements Message ----------------------------------------------

  SelectableItemDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelectableItemDTO& from);
  void MergeFrom(const SelectableItemDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Caption = 1;
  inline bool has_caption() const;
  inline void clear_caption();
  static const int kCaptionFieldNumber = 1;
  inline const ::std::string& caption() const;
  inline void set_caption(const ::std::string& value);
  inline void set_caption(const char* value);
  inline void set_caption(const char* value, size_t size);
  inline ::std::string* mutable_caption();
  inline ::std::string* release_caption();
  inline void set_allocated_caption(::std::string* caption);

  // optional string ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bool IsInConflict = 3 [default = false];
  inline bool has_isinconflict() const;
  inline void clear_isinconflict();
  static const int kIsInConflictFieldNumber = 3;
  inline bool isinconflict() const;
  inline void set_isinconflict(bool value);

  // optional bool IsSelected = 4 [default = false];
  inline bool has_isselected() const;
  inline void clear_isselected();
  static const int kIsSelectedFieldNumber = 4;
  inline bool isselected() const;
  inline void set_isselected(bool value);

  // @@protoc_insertion_point(class_scope:SelectableItemDTO)
 private:
  inline void set_has_caption();
  inline void clear_has_caption();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isinconflict();
  inline void clear_has_isinconflict();
  inline void set_has_isselected();
  inline void clear_has_isselected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* caption_;
  ::std::string* id_;
  bool isinconflict_;
  bool isselected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static SelectableItemDTO* default_instance_;
};
// -------------------------------------------------------------------

class StepDTO : public ::google::protobuf::Message {
 public:
  StepDTO();
  virtual ~StepDTO();

  StepDTO(const StepDTO& from);

  inline StepDTO& operator=(const StepDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepDTO& default_instance();

  void Swap(StepDTO* other);

  // implements Message ----------------------------------------------

  StepDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepDTO& from);
  void MergeFrom(const StepDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StepDTO)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static StepDTO* default_instance_;
};
// -------------------------------------------------------------------

class TransferPropertyDTO : public ::google::protobuf::Message {
 public:
  TransferPropertyDTO();
  virtual ~TransferPropertyDTO();

  TransferPropertyDTO(const TransferPropertyDTO& from);

  inline TransferPropertyDTO& operator=(const TransferPropertyDTO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferPropertyDTO& default_instance();

  void Swap(TransferPropertyDTO* other);

  // implements Message ----------------------------------------------

  TransferPropertyDTO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferPropertyDTO& from);
  void MergeFrom(const TransferPropertyDTO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool EnablePushToWorkstation = 1 [default = false];
  inline bool has_enablepushtoworkstation() const;
  inline void clear_enablepushtoworkstation();
  static const int kEnablePushToWorkstationFieldNumber = 1;
  inline bool enablepushtoworkstation() const;
  inline void set_enablepushtoworkstation(bool value);

  // optional bool IsCandidateForTransfer = 2 [default = false];
  inline bool has_iscandidatefortransfer() const;
  inline void clear_iscandidatefortransfer();
  static const int kIsCandidateForTransferFieldNumber = 2;
  inline bool iscandidatefortransfer() const;
  inline void set_iscandidatefortransfer(bool value);

  // optional bool PushToWorkstation = 3 [default = false];
  inline bool has_pushtoworkstation() const;
  inline void clear_pushtoworkstation();
  static const int kPushToWorkstationFieldNumber = 3;
  inline bool pushtoworkstation() const;
  inline void set_pushtoworkstation(bool value);

  // optional .SortOrder SliceOrder = 4 [default = ASCENDING];
  inline bool has_sliceorder() const;
  inline void clear_sliceorder();
  static const int kSliceOrderFieldNumber = 4;
  inline ::SortOrder sliceorder() const;
  inline void set_sliceorder(::SortOrder value);

  // repeated .SortAttributes SortingAttributes = 5;
  inline int sortingattributes_size() const;
  inline void clear_sortingattributes();
  static const int kSortingAttributesFieldNumber = 5;
  inline ::SortAttributes sortingattributes(int index) const;
  inline void set_sortingattributes(int index, ::SortAttributes value);
  inline void add_sortingattributes(::SortAttributes value);
  inline const ::google::protobuf::RepeatedField<int>& sortingattributes() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_sortingattributes();

  // @@protoc_insertion_point(class_scope:TransferPropertyDTO)
 private:
  inline void set_has_enablepushtoworkstation();
  inline void clear_has_enablepushtoworkstation();
  inline void set_has_iscandidatefortransfer();
  inline void clear_has_iscandidatefortransfer();
  inline void set_has_pushtoworkstation();
  inline void clear_has_pushtoworkstation();
  inline void set_has_sliceorder();
  inline void clear_has_sliceorder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enablepushtoworkstation_;
  bool iscandidatefortransfer_;
  bool pushtoworkstation_;
  int sliceorder_;
  ::google::protobuf::RepeatedField<int> sortingattributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ECViewmodel_2eproto();
  friend void protobuf_AssignDesc_ECViewmodel_2eproto();
  friend void protobuf_ShutdownFile_ECViewmodel_2eproto();

  void InitAsDefaultInstance();
  static TransferPropertyDTO* default_instance_;
};
// ===================================================================


// ===================================================================

// CellInfoDTO

// optional bool CanChange = 1 [default = false];
inline bool CellInfoDTO::has_canchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellInfoDTO::set_has_canchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CellInfoDTO::clear_has_canchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CellInfoDTO::clear_canchange() {
  canchange_ = false;
  clear_has_canchange();
}
inline bool CellInfoDTO::canchange() const {
  return canchange_;
}
inline void CellInfoDTO::set_canchange(bool value) {
  set_has_canchange();
  canchange_ = value;
}

// optional string Description = 2;
inline bool CellInfoDTO::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CellInfoDTO::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CellInfoDTO::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CellInfoDTO::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CellInfoDTO::description() const {
  return *description_;
}
inline void CellInfoDTO::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CellInfoDTO::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CellInfoDTO::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CellInfoDTO::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CellInfoDTO::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CellInfoDTO::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Object Value = 3;
inline bool CellInfoDTO::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CellInfoDTO::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CellInfoDTO::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CellInfoDTO::clear_value() {
  if (value_ != NULL) value_->::Object::Clear();
  clear_has_value();
}
inline const ::Object& CellInfoDTO::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Object* CellInfoDTO::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Object;
  return value_;
}
inline ::Object* CellInfoDTO::release_value() {
  clear_has_value();
  ::Object* temp = value_;
  value_ = NULL;
  return temp;
}
inline void CellInfoDTO::set_allocated_value(::Object* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// CipDTO

// optional string Agent = 1;
inline bool CipDTO::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CipDTO::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CipDTO::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CipDTO::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& CipDTO::agent() const {
  return *agent_;
}
inline void CipDTO::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CipDTO::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void CipDTO::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CipDTO::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* CipDTO::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CipDTO::set_allocated_agent(::std::string* agent) {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    delete agent_;
  }
  if (agent) {
    set_has_agent();
    agent_ = agent;
  } else {
    clear_has_agent();
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double Concentration = 2 [default = 0];
inline bool CipDTO::has_concentration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CipDTO::set_has_concentration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CipDTO::clear_has_concentration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CipDTO::clear_concentration() {
  concentration_ = 0;
  clear_has_concentration();
}
inline double CipDTO::concentration() const {
  return concentration_;
}
inline void CipDTO::set_concentration(double value) {
  set_has_concentration();
  concentration_ = value;
}

// optional bool Confirmed = 3 [default = false];
inline bool CipDTO::has_confirmed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CipDTO::set_has_confirmed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CipDTO::clear_has_confirmed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CipDTO::clear_confirmed() {
  confirmed_ = false;
  clear_has_confirmed();
}
inline bool CipDTO::confirmed() const {
  return confirmed_;
}
inline void CipDTO::set_confirmed(bool value) {
  set_has_confirmed();
  confirmed_ = value;
}

// optional bool Ignore = 4 [default = false];
inline bool CipDTO::has_ignore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CipDTO::set_has_ignore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CipDTO::clear_has_ignore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CipDTO::clear_ignore() {
  ignore_ = false;
  clear_has_ignore();
}
inline bool CipDTO::ignore() const {
  return ignore_;
}
inline void CipDTO::set_ignore(bool value) {
  set_has_ignore();
  ignore_ = value;
}

// optional uint32 InjectionStartDynamicNumber = 5 [default = 0];
inline bool CipDTO::has_injectionstartdynamicnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CipDTO::set_has_injectionstartdynamicnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CipDTO::clear_has_injectionstartdynamicnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CipDTO::clear_injectionstartdynamicnumber() {
  injectionstartdynamicnumber_ = 0u;
  clear_has_injectionstartdynamicnumber();
}
inline ::google::protobuf::uint32 CipDTO::injectionstartdynamicnumber() const {
  return injectionstartdynamicnumber_;
}
inline void CipDTO::set_injectionstartdynamicnumber(::google::protobuf::uint32 value) {
  set_has_injectionstartdynamicnumber();
  injectionstartdynamicnumber_ = value;
}

// optional bool Manual = 6 [default = false];
inline bool CipDTO::has_manual() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CipDTO::set_has_manual() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CipDTO::clear_has_manual() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CipDTO::clear_manual() {
  manual_ = false;
  clear_has_manual();
}
inline bool CipDTO::manual() const {
  return manual_;
}
inline void CipDTO::set_manual(bool value) {
  set_has_manual();
  manual_ = value;
}

// optional string RouteOfAdministration = 7;
inline bool CipDTO::has_routeofadministration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CipDTO::set_has_routeofadministration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CipDTO::clear_has_routeofadministration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CipDTO::clear_routeofadministration() {
  if (routeofadministration_ != &::google::protobuf::internal::kEmptyString) {
    routeofadministration_->clear();
  }
  clear_has_routeofadministration();
}
inline const ::std::string& CipDTO::routeofadministration() const {
  return *routeofadministration_;
}
inline void CipDTO::set_routeofadministration(const ::std::string& value) {
  set_has_routeofadministration();
  if (routeofadministration_ == &::google::protobuf::internal::kEmptyString) {
    routeofadministration_ = new ::std::string;
  }
  routeofadministration_->assign(value);
}
inline void CipDTO::set_routeofadministration(const char* value) {
  set_has_routeofadministration();
  if (routeofadministration_ == &::google::protobuf::internal::kEmptyString) {
    routeofadministration_ = new ::std::string;
  }
  routeofadministration_->assign(value);
}
inline void CipDTO::set_routeofadministration(const char* value, size_t size) {
  set_has_routeofadministration();
  if (routeofadministration_ == &::google::protobuf::internal::kEmptyString) {
    routeofadministration_ = new ::std::string;
  }
  routeofadministration_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CipDTO::mutable_routeofadministration() {
  set_has_routeofadministration();
  if (routeofadministration_ == &::google::protobuf::internal::kEmptyString) {
    routeofadministration_ = new ::std::string;
  }
  return routeofadministration_;
}
inline ::std::string* CipDTO::release_routeofadministration() {
  clear_has_routeofadministration();
  if (routeofadministration_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = routeofadministration_;
    routeofadministration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CipDTO::set_allocated_routeofadministration(::std::string* routeofadministration) {
  if (routeofadministration_ != &::google::protobuf::internal::kEmptyString) {
    delete routeofadministration_;
  }
  if (routeofadministration) {
    set_has_routeofadministration();
    routeofadministration_ = routeofadministration;
  } else {
    clear_has_routeofadministration();
    routeofadministration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double Volume = 8 [default = 0];
inline bool CipDTO::has_volume() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CipDTO::set_has_volume() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CipDTO::clear_has_volume() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CipDTO::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double CipDTO::volume() const {
  return volume_;
}
inline void CipDTO::set_volume(double value) {
  set_has_volume();
  volume_ = value;
}

// -------------------------------------------------------------------

// ConfirmReviewTypeDTO

// optional string Key = 1;
inline bool ConfirmReviewTypeDTO::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfirmReviewTypeDTO::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfirmReviewTypeDTO::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfirmReviewTypeDTO::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ConfirmReviewTypeDTO::key() const {
  return *key_;
}
inline void ConfirmReviewTypeDTO::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ConfirmReviewTypeDTO::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ConfirmReviewTypeDTO::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfirmReviewTypeDTO::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ConfirmReviewTypeDTO::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfirmReviewTypeDTO::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Value = 2;
inline bool ConfirmReviewTypeDTO::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfirmReviewTypeDTO::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfirmReviewTypeDTO::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfirmReviewTypeDTO::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ConfirmReviewTypeDTO::value() const {
  return *value_;
}
inline void ConfirmReviewTypeDTO::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfirmReviewTypeDTO::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfirmReviewTypeDTO::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfirmReviewTypeDTO::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ConfirmReviewTypeDTO::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfirmReviewTypeDTO::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DTOBase

// optional .IAdapter Adapter = 1;
inline bool DTOBase::has_adapter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DTOBase::set_has_adapter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DTOBase::clear_has_adapter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DTOBase::clear_adapter() {
  if (adapter_ != NULL) adapter_->::IAdapter::Clear();
  clear_has_adapter();
}
inline const ::IAdapter& DTOBase::adapter() const {
  return adapter_ != NULL ? *adapter_ : *default_instance_->adapter_;
}
inline ::IAdapter* DTOBase::mutable_adapter() {
  set_has_adapter();
  if (adapter_ == NULL) adapter_ = new ::IAdapter;
  return adapter_;
}
inline ::IAdapter* DTOBase::release_adapter() {
  clear_has_adapter();
  ::IAdapter* temp = adapter_;
  adapter_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_adapter(::IAdapter* adapter) {
  delete adapter_;
  adapter_ = adapter;
  if (adapter) {
    set_has_adapter();
  } else {
    clear_has_adapter();
  }
}

// repeated .Object Tag = 2;
inline int DTOBase::tag_size() const {
  return tag_.size();
}
inline void DTOBase::clear_tag() {
  tag_.Clear();
}
inline const ::Object& DTOBase::tag(int index) const {
  return tag_.Get(index);
}
inline ::Object* DTOBase::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline ::Object* DTOBase::add_tag() {
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Object >&
DTOBase::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::Object >*
DTOBase::mutable_tag() {
  return &tag_;
}

// optional bool Validation = 3 [default = false];
inline bool DTOBase::has_validation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DTOBase::set_has_validation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DTOBase::clear_has_validation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DTOBase::clear_validation() {
  validation_ = false;
  clear_has_validation();
}
inline bool DTOBase::validation() const {
  return validation_;
}
inline void DTOBase::set_validation(bool value) {
  set_has_validation();
  validation_ = value;
}

// optional .CellInfoDTO CellInfoDTO = 10;
inline bool DTOBase::has_cellinfodto() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DTOBase::set_has_cellinfodto() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DTOBase::clear_has_cellinfodto() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DTOBase::clear_cellinfodto() {
  if (cellinfodto_ != NULL) cellinfodto_->::CellInfoDTO::Clear();
  clear_has_cellinfodto();
}
inline const ::CellInfoDTO& DTOBase::cellinfodto() const {
  return cellinfodto_ != NULL ? *cellinfodto_ : *default_instance_->cellinfodto_;
}
inline ::CellInfoDTO* DTOBase::mutable_cellinfodto() {
  set_has_cellinfodto();
  if (cellinfodto_ == NULL) cellinfodto_ = new ::CellInfoDTO;
  return cellinfodto_;
}
inline ::CellInfoDTO* DTOBase::release_cellinfodto() {
  clear_has_cellinfodto();
  ::CellInfoDTO* temp = cellinfodto_;
  cellinfodto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_cellinfodto(::CellInfoDTO* cellinfodto) {
  delete cellinfodto_;
  cellinfodto_ = cellinfodto;
  if (cellinfodto) {
    set_has_cellinfodto();
  } else {
    clear_has_cellinfodto();
  }
}

// optional .CipDTO CipDTO = 20;
inline bool DTOBase::has_cipdto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DTOBase::set_has_cipdto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DTOBase::clear_has_cipdto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DTOBase::clear_cipdto() {
  if (cipdto_ != NULL) cipdto_->::CipDTO::Clear();
  clear_has_cipdto();
}
inline const ::CipDTO& DTOBase::cipdto() const {
  return cipdto_ != NULL ? *cipdto_ : *default_instance_->cipdto_;
}
inline ::CipDTO* DTOBase::mutable_cipdto() {
  set_has_cipdto();
  if (cipdto_ == NULL) cipdto_ = new ::CipDTO;
  return cipdto_;
}
inline ::CipDTO* DTOBase::release_cipdto() {
  clear_has_cipdto();
  ::CipDTO* temp = cipdto_;
  cipdto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_cipdto(::CipDTO* cipdto) {
  delete cipdto_;
  cipdto_ = cipdto;
  if (cipdto) {
    set_has_cipdto();
  } else {
    clear_has_cipdto();
  }
}

// optional .ConfirmReviewTypeDTO ConfirmReviewTypeDTO = 30;
inline bool DTOBase::has_confirmreviewtypedto() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DTOBase::set_has_confirmreviewtypedto() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DTOBase::clear_has_confirmreviewtypedto() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DTOBase::clear_confirmreviewtypedto() {
  if (confirmreviewtypedto_ != NULL) confirmreviewtypedto_->::ConfirmReviewTypeDTO::Clear();
  clear_has_confirmreviewtypedto();
}
inline const ::ConfirmReviewTypeDTO& DTOBase::confirmreviewtypedto() const {
  return confirmreviewtypedto_ != NULL ? *confirmreviewtypedto_ : *default_instance_->confirmreviewtypedto_;
}
inline ::ConfirmReviewTypeDTO* DTOBase::mutable_confirmreviewtypedto() {
  set_has_confirmreviewtypedto();
  if (confirmreviewtypedto_ == NULL) confirmreviewtypedto_ = new ::ConfirmReviewTypeDTO;
  return confirmreviewtypedto_;
}
inline ::ConfirmReviewTypeDTO* DTOBase::release_confirmreviewtypedto() {
  clear_has_confirmreviewtypedto();
  ::ConfirmReviewTypeDTO* temp = confirmreviewtypedto_;
  confirmreviewtypedto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_confirmreviewtypedto(::ConfirmReviewTypeDTO* confirmreviewtypedto) {
  delete confirmreviewtypedto_;
  confirmreviewtypedto_ = confirmreviewtypedto;
  if (confirmreviewtypedto) {
    set_has_confirmreviewtypedto();
  } else {
    clear_has_confirmreviewtypedto();
  }
}

// optional .ExamCardPropertyDTO ExamCardPropertyDTO = 40;
inline bool DTOBase::has_examcardpropertydto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DTOBase::set_has_examcardpropertydto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DTOBase::clear_has_examcardpropertydto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DTOBase::clear_examcardpropertydto() {
  if (examcardpropertydto_ != NULL) examcardpropertydto_->::ExamCardPropertyDTO::Clear();
  clear_has_examcardpropertydto();
}
inline const ::ExamCardPropertyDTO& DTOBase::examcardpropertydto() const {
  return examcardpropertydto_ != NULL ? *examcardpropertydto_ : *default_instance_->examcardpropertydto_;
}
inline ::ExamCardPropertyDTO* DTOBase::mutable_examcardpropertydto() {
  set_has_examcardpropertydto();
  if (examcardpropertydto_ == NULL) examcardpropertydto_ = new ::ExamCardPropertyDTO;
  return examcardpropertydto_;
}
inline ::ExamCardPropertyDTO* DTOBase::release_examcardpropertydto() {
  clear_has_examcardpropertydto();
  ::ExamCardPropertyDTO* temp = examcardpropertydto_;
  examcardpropertydto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_examcardpropertydto(::ExamCardPropertyDTO* examcardpropertydto) {
  delete examcardpropertydto_;
  examcardpropertydto_ = examcardpropertydto;
  if (examcardpropertydto) {
    set_has_examcardpropertydto();
  } else {
    clear_has_examcardpropertydto();
  }
}

// optional .SelectableItemDTO SelectableItemDTO = 50;
inline bool DTOBase::has_selectableitemdto() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DTOBase::set_has_selectableitemdto() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DTOBase::clear_has_selectableitemdto() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DTOBase::clear_selectableitemdto() {
  if (selectableitemdto_ != NULL) selectableitemdto_->::SelectableItemDTO::Clear();
  clear_has_selectableitemdto();
}
inline const ::SelectableItemDTO& DTOBase::selectableitemdto() const {
  return selectableitemdto_ != NULL ? *selectableitemdto_ : *default_instance_->selectableitemdto_;
}
inline ::SelectableItemDTO* DTOBase::mutable_selectableitemdto() {
  set_has_selectableitemdto();
  if (selectableitemdto_ == NULL) selectableitemdto_ = new ::SelectableItemDTO;
  return selectableitemdto_;
}
inline ::SelectableItemDTO* DTOBase::release_selectableitemdto() {
  clear_has_selectableitemdto();
  ::SelectableItemDTO* temp = selectableitemdto_;
  selectableitemdto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_selectableitemdto(::SelectableItemDTO* selectableitemdto) {
  delete selectableitemdto_;
  selectableitemdto_ = selectableitemdto;
  if (selectableitemdto) {
    set_has_selectableitemdto();
  } else {
    clear_has_selectableitemdto();
  }
}

// optional .TransferPropertyDTO TransferPropertyDTO = 60;
inline bool DTOBase::has_transferpropertydto() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DTOBase::set_has_transferpropertydto() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DTOBase::clear_has_transferpropertydto() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DTOBase::clear_transferpropertydto() {
  if (transferpropertydto_ != NULL) transferpropertydto_->::TransferPropertyDTO::Clear();
  clear_has_transferpropertydto();
}
inline const ::TransferPropertyDTO& DTOBase::transferpropertydto() const {
  return transferpropertydto_ != NULL ? *transferpropertydto_ : *default_instance_->transferpropertydto_;
}
inline ::TransferPropertyDTO* DTOBase::mutable_transferpropertydto() {
  set_has_transferpropertydto();
  if (transferpropertydto_ == NULL) transferpropertydto_ = new ::TransferPropertyDTO;
  return transferpropertydto_;
}
inline ::TransferPropertyDTO* DTOBase::release_transferpropertydto() {
  clear_has_transferpropertydto();
  ::TransferPropertyDTO* temp = transferpropertydto_;
  transferpropertydto_ = NULL;
  return temp;
}
inline void DTOBase::set_allocated_transferpropertydto(::TransferPropertyDTO* transferpropertydto) {
  delete transferpropertydto_;
  transferpropertydto_ = transferpropertydto;
  if (transferpropertydto) {
    set_has_transferpropertydto();
  } else {
    clear_has_transferpropertydto();
  }
}

// -------------------------------------------------------------------

// ElementBase

// repeated .ElementBase ChildElements = 1;
inline int ElementBase::childelements_size() const {
  return childelements_.size();
}
inline void ElementBase::clear_childelements() {
  childelements_.Clear();
}
inline const ::ElementBase& ElementBase::childelements(int index) const {
  return childelements_.Get(index);
}
inline ::ElementBase* ElementBase::mutable_childelements(int index) {
  return childelements_.Mutable(index);
}
inline ::ElementBase* ElementBase::add_childelements() {
  return childelements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
ElementBase::childelements() const {
  return childelements_;
}
inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
ElementBase::mutable_childelements() {
  return &childelements_;
}

// optional bool Enabled = 2 [default = false];
inline bool ElementBase::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElementBase::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElementBase::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElementBase::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ElementBase::enabled() const {
  return enabled_;
}
inline void ElementBase::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional bool Expanded = 3 [default = false];
inline bool ElementBase::has_expanded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElementBase::set_has_expanded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElementBase::clear_has_expanded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElementBase::clear_expanded() {
  expanded_ = false;
  clear_has_expanded();
}
inline bool ElementBase::expanded() const {
  return expanded_;
}
inline void ElementBase::set_expanded(bool value) {
  set_has_expanded();
  expanded_ = value;
}

// optional bool Invisible = 4 [default = false];
inline bool ElementBase::has_invisible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElementBase::set_has_invisible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ElementBase::clear_has_invisible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ElementBase::clear_invisible() {
  invisible_ = false;
  clear_has_invisible();
}
inline bool ElementBase::invisible() const {
  return invisible_;
}
inline void ElementBase::set_invisible(bool value) {
  set_has_invisible();
  invisible_ = value;
}

// optional .ElementBase Parent = 5;
inline bool ElementBase::has_parent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ElementBase::set_has_parent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ElementBase::clear_has_parent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ElementBase::clear_parent() {
  if (parent_ != NULL) parent_->::ElementBase::Clear();
  clear_has_parent();
}
inline const ::ElementBase& ElementBase::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::ElementBase* ElementBase::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::ElementBase;
  return parent_;
}
inline ::ElementBase* ElementBase::release_parent() {
  clear_has_parent();
  ::ElementBase* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void ElementBase::set_allocated_parent(::ElementBase* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
}

// optional bool Selected = 6 [default = false];
inline bool ElementBase::has_selected() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ElementBase::set_has_selected() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ElementBase::clear_has_selected() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ElementBase::clear_selected() {
  selected_ = false;
  clear_has_selected();
}
inline bool ElementBase::selected() const {
  return selected_;
}
inline void ElementBase::set_selected(bool value) {
  set_has_selected();
  selected_ = value;
}

// optional .ExamCardDTO ExamCardDTO = 100;
inline bool ElementBase::has_examcarddto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ElementBase::set_has_examcarddto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ElementBase::clear_has_examcarddto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ElementBase::clear_examcarddto() {
  if (examcarddto_ != NULL) examcarddto_->::ExamCardDTO::Clear();
  clear_has_examcarddto();
}
inline const ::ExamCardDTO& ElementBase::examcarddto() const {
  return examcarddto_ != NULL ? *examcarddto_ : *default_instance_->examcarddto_;
}
inline ::ExamCardDTO* ElementBase::mutable_examcarddto() {
  set_has_examcarddto();
  if (examcarddto_ == NULL) examcarddto_ = new ::ExamCardDTO;
  return examcarddto_;
}
inline ::ExamCardDTO* ElementBase::release_examcarddto() {
  clear_has_examcarddto();
  ::ExamCardDTO* temp = examcarddto_;
  examcarddto_ = NULL;
  return temp;
}
inline void ElementBase::set_allocated_examcarddto(::ExamCardDTO* examcarddto) {
  delete examcarddto_;
  examcarddto_ = examcarddto;
  if (examcarddto) {
    set_has_examcarddto();
  } else {
    clear_has_examcarddto();
  }
}

// optional .StepDTO StepDTO = 200;
inline bool ElementBase::has_stepdto() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ElementBase::set_has_stepdto() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ElementBase::clear_has_stepdto() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ElementBase::clear_stepdto() {
  if (stepdto_ != NULL) stepdto_->::StepDTO::Clear();
  clear_has_stepdto();
}
inline const ::StepDTO& ElementBase::stepdto() const {
  return stepdto_ != NULL ? *stepdto_ : *default_instance_->stepdto_;
}
inline ::StepDTO* ElementBase::mutable_stepdto() {
  set_has_stepdto();
  if (stepdto_ == NULL) stepdto_ = new ::StepDTO;
  return stepdto_;
}
inline ::StepDTO* ElementBase::release_stepdto() {
  clear_has_stepdto();
  ::StepDTO* temp = stepdto_;
  stepdto_ = NULL;
  return temp;
}
inline void ElementBase::set_allocated_stepdto(::StepDTO* stepdto) {
  delete stepdto_;
  stepdto_ = stepdto;
  if (stepdto) {
    set_has_stepdto();
  } else {
    clear_has_stepdto();
  }
}

// optional .ScanSetDTO ScanSetDTO = 300;
inline bool ElementBase::has_scansetdto() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ElementBase::set_has_scansetdto() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ElementBase::clear_has_scansetdto() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ElementBase::clear_scansetdto() {
  if (scansetdto_ != NULL) scansetdto_->::ScanSetDTO::Clear();
  clear_has_scansetdto();
}
inline const ::ScanSetDTO& ElementBase::scansetdto() const {
  return scansetdto_ != NULL ? *scansetdto_ : *default_instance_->scansetdto_;
}
inline ::ScanSetDTO* ElementBase::mutable_scansetdto() {
  set_has_scansetdto();
  if (scansetdto_ == NULL) scansetdto_ = new ::ScanSetDTO;
  return scansetdto_;
}
inline ::ScanSetDTO* ElementBase::release_scansetdto() {
  clear_has_scansetdto();
  ::ScanSetDTO* temp = scansetdto_;
  scansetdto_ = NULL;
  return temp;
}
inline void ElementBase::set_allocated_scansetdto(::ScanSetDTO* scansetdto) {
  delete scansetdto_;
  scansetdto_ = scansetdto;
  if (scansetdto) {
    set_has_scansetdto();
  } else {
    clear_has_scansetdto();
  }
}

// -------------------------------------------------------------------

// ExamCardDTO

// repeated .ElementBase ChildElements = 1;
inline int ExamCardDTO::childelements_size() const {
  return childelements_.size();
}
inline void ExamCardDTO::clear_childelements() {
  childelements_.Clear();
}
inline const ::ElementBase& ExamCardDTO::childelements(int index) const {
  return childelements_.Get(index);
}
inline ::ElementBase* ExamCardDTO::mutable_childelements(int index) {
  return childelements_.Mutable(index);
}
inline ::ElementBase* ExamCardDTO::add_childelements() {
  return childelements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
ExamCardDTO::childelements() const {
  return childelements_;
}
inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
ExamCardDTO::mutable_childelements() {
  return &childelements_;
}

// optional string ExamCardDescription = 2;
inline bool ExamCardDTO::has_examcarddescription() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExamCardDTO::set_has_examcarddescription() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExamCardDTO::clear_has_examcarddescription() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExamCardDTO::clear_examcarddescription() {
  if (examcarddescription_ != &::google::protobuf::internal::kEmptyString) {
    examcarddescription_->clear();
  }
  clear_has_examcarddescription();
}
inline const ::std::string& ExamCardDTO::examcarddescription() const {
  return *examcarddescription_;
}
inline void ExamCardDTO::set_examcarddescription(const ::std::string& value) {
  set_has_examcarddescription();
  if (examcarddescription_ == &::google::protobuf::internal::kEmptyString) {
    examcarddescription_ = new ::std::string;
  }
  examcarddescription_->assign(value);
}
inline void ExamCardDTO::set_examcarddescription(const char* value) {
  set_has_examcarddescription();
  if (examcarddescription_ == &::google::protobuf::internal::kEmptyString) {
    examcarddescription_ = new ::std::string;
  }
  examcarddescription_->assign(value);
}
inline void ExamCardDTO::set_examcarddescription(const char* value, size_t size) {
  set_has_examcarddescription();
  if (examcarddescription_ == &::google::protobuf::internal::kEmptyString) {
    examcarddescription_ = new ::std::string;
  }
  examcarddescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardDTO::mutable_examcarddescription() {
  set_has_examcarddescription();
  if (examcarddescription_ == &::google::protobuf::internal::kEmptyString) {
    examcarddescription_ = new ::std::string;
  }
  return examcarddescription_;
}
inline ::std::string* ExamCardDTO::release_examcarddescription() {
  clear_has_examcarddescription();
  if (examcarddescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = examcarddescription_;
    examcarddescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardDTO::set_allocated_examcarddescription(::std::string* examcarddescription) {
  if (examcarddescription_ != &::google::protobuf::internal::kEmptyString) {
    delete examcarddescription_;
  }
  if (examcarddescription) {
    set_has_examcarddescription();
    examcarddescription_ = examcarddescription;
  } else {
    clear_has_examcarddescription();
    examcarddescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .DTOBase ExamCardProperty = 3;
inline bool ExamCardDTO::has_examcardproperty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExamCardDTO::set_has_examcardproperty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExamCardDTO::clear_has_examcardproperty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExamCardDTO::clear_examcardproperty() {
  if (examcardproperty_ != NULL) examcardproperty_->::DTOBase::Clear();
  clear_has_examcardproperty();
}
inline const ::DTOBase& ExamCardDTO::examcardproperty() const {
  return examcardproperty_ != NULL ? *examcardproperty_ : *default_instance_->examcardproperty_;
}
inline ::DTOBase* ExamCardDTO::mutable_examcardproperty() {
  set_has_examcardproperty();
  if (examcardproperty_ == NULL) examcardproperty_ = new ::DTOBase;
  return examcardproperty_;
}
inline ::DTOBase* ExamCardDTO::release_examcardproperty() {
  clear_has_examcardproperty();
  ::DTOBase* temp = examcardproperty_;
  examcardproperty_ = NULL;
  return temp;
}
inline void ExamCardDTO::set_allocated_examcardproperty(::DTOBase* examcardproperty) {
  delete examcardproperty_;
  examcardproperty_ = examcardproperty;
  if (examcardproperty) {
    set_has_examcardproperty();
  } else {
    clear_has_examcardproperty();
  }
}

// optional string Name = 4;
inline bool ExamCardDTO::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExamCardDTO::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExamCardDTO::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExamCardDTO::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExamCardDTO::name() const {
  return *name_;
}
inline void ExamCardDTO::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExamCardDTO::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExamCardDTO::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardDTO::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExamCardDTO::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardDTO::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExamCardPropertyDTO

// optional float AlignOverlap = 1 [default = 0];
inline bool ExamCardPropertyDTO::has_alignoverlap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExamCardPropertyDTO::set_has_alignoverlap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExamCardPropertyDTO::clear_has_alignoverlap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExamCardPropertyDTO::clear_alignoverlap() {
  alignoverlap_ = 0;
  clear_has_alignoverlap();
}
inline float ExamCardPropertyDTO::alignoverlap() const {
  return alignoverlap_;
}
inline void ExamCardPropertyDTO::set_alignoverlap(float value) {
  set_has_alignoverlap();
  alignoverlap_ = value;
}

// optional string AnatomicRegion = 2;
inline bool ExamCardPropertyDTO::has_anatomicregion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExamCardPropertyDTO::set_has_anatomicregion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExamCardPropertyDTO::clear_has_anatomicregion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExamCardPropertyDTO::clear_anatomicregion() {
  if (anatomicregion_ != &::google::protobuf::internal::kEmptyString) {
    anatomicregion_->clear();
  }
  clear_has_anatomicregion();
}
inline const ::std::string& ExamCardPropertyDTO::anatomicregion() const {
  return *anatomicregion_;
}
inline void ExamCardPropertyDTO::set_anatomicregion(const ::std::string& value) {
  set_has_anatomicregion();
  if (anatomicregion_ == &::google::protobuf::internal::kEmptyString) {
    anatomicregion_ = new ::std::string;
  }
  anatomicregion_->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomicregion(const char* value) {
  set_has_anatomicregion();
  if (anatomicregion_ == &::google::protobuf::internal::kEmptyString) {
    anatomicregion_ = new ::std::string;
  }
  anatomicregion_->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomicregion(const char* value, size_t size) {
  set_has_anatomicregion();
  if (anatomicregion_ == &::google::protobuf::internal::kEmptyString) {
    anatomicregion_ = new ::std::string;
  }
  anatomicregion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_anatomicregion() {
  set_has_anatomicregion();
  if (anatomicregion_ == &::google::protobuf::internal::kEmptyString) {
    anatomicregion_ = new ::std::string;
  }
  return anatomicregion_;
}
inline ::std::string* ExamCardPropertyDTO::release_anatomicregion() {
  clear_has_anatomicregion();
  if (anatomicregion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = anatomicregion_;
    anatomicregion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_anatomicregion(::std::string* anatomicregion) {
  if (anatomicregion_ != &::google::protobuf::internal::kEmptyString) {
    delete anatomicregion_;
  }
  if (anatomicregion) {
    set_has_anatomicregion();
    anatomicregion_ = anatomicregion;
  } else {
    clear_has_anatomicregion();
    anatomicregion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string AnatomicRegionsList = 3;
inline int ExamCardPropertyDTO::anatomicregionslist_size() const {
  return anatomicregionslist_.size();
}
inline void ExamCardPropertyDTO::clear_anatomicregionslist() {
  anatomicregionslist_.Clear();
}
inline const ::std::string& ExamCardPropertyDTO::anatomicregionslist(int index) const {
  return anatomicregionslist_.Get(index);
}
inline ::std::string* ExamCardPropertyDTO::mutable_anatomicregionslist(int index) {
  return anatomicregionslist_.Mutable(index);
}
inline void ExamCardPropertyDTO::set_anatomicregionslist(int index, const ::std::string& value) {
  anatomicregionslist_.Mutable(index)->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomicregionslist(int index, const char* value) {
  anatomicregionslist_.Mutable(index)->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomicregionslist(int index, const char* value, size_t size) {
  anatomicregionslist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::add_anatomicregionslist() {
  return anatomicregionslist_.Add();
}
inline void ExamCardPropertyDTO::add_anatomicregionslist(const ::std::string& value) {
  anatomicregionslist_.Add()->assign(value);
}
inline void ExamCardPropertyDTO::add_anatomicregionslist(const char* value) {
  anatomicregionslist_.Add()->assign(value);
}
inline void ExamCardPropertyDTO::add_anatomicregionslist(const char* value, size_t size) {
  anatomicregionslist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExamCardPropertyDTO::anatomicregionslist() const {
  return anatomicregionslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExamCardPropertyDTO::mutable_anatomicregionslist() {
  return &anatomicregionslist_;
}

// repeated string AnatomiesList = 4;
inline int ExamCardPropertyDTO::anatomieslist_size() const {
  return anatomieslist_.size();
}
inline void ExamCardPropertyDTO::clear_anatomieslist() {
  anatomieslist_.Clear();
}
inline const ::std::string& ExamCardPropertyDTO::anatomieslist(int index) const {
  return anatomieslist_.Get(index);
}
inline ::std::string* ExamCardPropertyDTO::mutable_anatomieslist(int index) {
  return anatomieslist_.Mutable(index);
}
inline void ExamCardPropertyDTO::set_anatomieslist(int index, const ::std::string& value) {
  anatomieslist_.Mutable(index)->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomieslist(int index, const char* value) {
  anatomieslist_.Mutable(index)->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomieslist(int index, const char* value, size_t size) {
  anatomieslist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::add_anatomieslist() {
  return anatomieslist_.Add();
}
inline void ExamCardPropertyDTO::add_anatomieslist(const ::std::string& value) {
  anatomieslist_.Add()->assign(value);
}
inline void ExamCardPropertyDTO::add_anatomieslist(const char* value) {
  anatomieslist_.Add()->assign(value);
}
inline void ExamCardPropertyDTO::add_anatomieslist(const char* value, size_t size) {
  anatomieslist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExamCardPropertyDTO::anatomieslist() const {
  return anatomieslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExamCardPropertyDTO::mutable_anatomieslist() {
  return &anatomieslist_;
}

// optional string Anatomy = 5;
inline bool ExamCardPropertyDTO::has_anatomy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExamCardPropertyDTO::set_has_anatomy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExamCardPropertyDTO::clear_has_anatomy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExamCardPropertyDTO::clear_anatomy() {
  if (anatomy_ != &::google::protobuf::internal::kEmptyString) {
    anatomy_->clear();
  }
  clear_has_anatomy();
}
inline const ::std::string& ExamCardPropertyDTO::anatomy() const {
  return *anatomy_;
}
inline void ExamCardPropertyDTO::set_anatomy(const ::std::string& value) {
  set_has_anatomy();
  if (anatomy_ == &::google::protobuf::internal::kEmptyString) {
    anatomy_ = new ::std::string;
  }
  anatomy_->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomy(const char* value) {
  set_has_anatomy();
  if (anatomy_ == &::google::protobuf::internal::kEmptyString) {
    anatomy_ = new ::std::string;
  }
  anatomy_->assign(value);
}
inline void ExamCardPropertyDTO::set_anatomy(const char* value, size_t size) {
  set_has_anatomy();
  if (anatomy_ == &::google::protobuf::internal::kEmptyString) {
    anatomy_ = new ::std::string;
  }
  anatomy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_anatomy() {
  set_has_anatomy();
  if (anatomy_ == &::google::protobuf::internal::kEmptyString) {
    anatomy_ = new ::std::string;
  }
  return anatomy_;
}
inline ::std::string* ExamCardPropertyDTO::release_anatomy() {
  clear_has_anatomy();
  if (anatomy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = anatomy_;
    anatomy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_anatomy(::std::string* anatomy) {
  if (anatomy_ != &::google::protobuf::internal::kEmptyString) {
    delete anatomy_;
  }
  if (anatomy) {
    set_has_anatomy();
    anatomy_ = anatomy;
  } else {
    clear_has_anatomy();
    anatomy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool AutoFillInHeartRate = 6 [default = false];
inline bool ExamCardPropertyDTO::has_autofillinheartrate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExamCardPropertyDTO::set_has_autofillinheartrate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExamCardPropertyDTO::clear_has_autofillinheartrate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExamCardPropertyDTO::clear_autofillinheartrate() {
  autofillinheartrate_ = false;
  clear_has_autofillinheartrate();
}
inline bool ExamCardPropertyDTO::autofillinheartrate() const {
  return autofillinheartrate_;
}
inline void ExamCardPropertyDTO::set_autofillinheartrate(bool value) {
  set_has_autofillinheartrate();
  autofillinheartrate_ = value;
}

// optional bool AutoFillInHeartRateAllowed = 7 [default = false];
inline bool ExamCardPropertyDTO::has_autofillinheartrateallowed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExamCardPropertyDTO::set_has_autofillinheartrateallowed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExamCardPropertyDTO::clear_has_autofillinheartrateallowed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExamCardPropertyDTO::clear_autofillinheartrateallowed() {
  autofillinheartrateallowed_ = false;
  clear_has_autofillinheartrateallowed();
}
inline bool ExamCardPropertyDTO::autofillinheartrateallowed() const {
  return autofillinheartrateallowed_;
}
inline void ExamCardPropertyDTO::set_autofillinheartrateallowed(bool value) {
  set_has_autofillinheartrateallowed();
  autofillinheartrateallowed_ = value;
}

// repeated .DTOBase ConfiguredCoils = 8;
inline int ExamCardPropertyDTO::configuredcoils_size() const {
  return configuredcoils_.size();
}
inline void ExamCardPropertyDTO::clear_configuredcoils() {
  configuredcoils_.Clear();
}
inline const ::DTOBase& ExamCardPropertyDTO::configuredcoils(int index) const {
  return configuredcoils_.Get(index);
}
inline ::DTOBase* ExamCardPropertyDTO::mutable_configuredcoils(int index) {
  return configuredcoils_.Mutable(index);
}
inline ::DTOBase* ExamCardPropertyDTO::add_configuredcoils() {
  return configuredcoils_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
ExamCardPropertyDTO::configuredcoils() const {
  return configuredcoils_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
ExamCardPropertyDTO::mutable_configuredcoils() {
  return &configuredcoils_;
}

// optional string DockingMode = 9;
inline bool ExamCardPropertyDTO::has_dockingmode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExamCardPropertyDTO::set_has_dockingmode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExamCardPropertyDTO::clear_has_dockingmode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExamCardPropertyDTO::clear_dockingmode() {
  if (dockingmode_ != &::google::protobuf::internal::kEmptyString) {
    dockingmode_->clear();
  }
  clear_has_dockingmode();
}
inline const ::std::string& ExamCardPropertyDTO::dockingmode() const {
  return *dockingmode_;
}
inline void ExamCardPropertyDTO::set_dockingmode(const ::std::string& value) {
  set_has_dockingmode();
  if (dockingmode_ == &::google::protobuf::internal::kEmptyString) {
    dockingmode_ = new ::std::string;
  }
  dockingmode_->assign(value);
}
inline void ExamCardPropertyDTO::set_dockingmode(const char* value) {
  set_has_dockingmode();
  if (dockingmode_ == &::google::protobuf::internal::kEmptyString) {
    dockingmode_ = new ::std::string;
  }
  dockingmode_->assign(value);
}
inline void ExamCardPropertyDTO::set_dockingmode(const char* value, size_t size) {
  set_has_dockingmode();
  if (dockingmode_ == &::google::protobuf::internal::kEmptyString) {
    dockingmode_ = new ::std::string;
  }
  dockingmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_dockingmode() {
  set_has_dockingmode();
  if (dockingmode_ == &::google::protobuf::internal::kEmptyString) {
    dockingmode_ = new ::std::string;
  }
  return dockingmode_;
}
inline ::std::string* ExamCardPropertyDTO::release_dockingmode() {
  clear_has_dockingmode();
  if (dockingmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dockingmode_;
    dockingmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_dockingmode(::std::string* dockingmode) {
  if (dockingmode_ != &::google::protobuf::internal::kEmptyString) {
    delete dockingmode_;
  }
  if (dockingmode) {
    set_has_dockingmode();
    dockingmode_ = dockingmode;
  } else {
    clear_has_dockingmode();
    dockingmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ExamDuration = 10 [default = 0];
inline bool ExamCardPropertyDTO::has_examduration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExamCardPropertyDTO::set_has_examduration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExamCardPropertyDTO::clear_has_examduration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExamCardPropertyDTO::clear_examduration() {
  examduration_ = 0;
  clear_has_examduration();
}
inline ::google::protobuf::int32 ExamCardPropertyDTO::examduration() const {
  return examduration_;
}
inline void ExamCardPropertyDTO::set_examduration(::google::protobuf::int32 value) {
  set_has_examduration();
  examduration_ = value;
}

// optional bool GeoLinkPropagation = 11 [default = false];
inline bool ExamCardPropertyDTO::has_geolinkpropagation() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExamCardPropertyDTO::set_has_geolinkpropagation() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExamCardPropertyDTO::clear_has_geolinkpropagation() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExamCardPropertyDTO::clear_geolinkpropagation() {
  geolinkpropagation_ = false;
  clear_has_geolinkpropagation();
}
inline bool ExamCardPropertyDTO::geolinkpropagation() const {
  return geolinkpropagation_;
}
inline void ExamCardPropertyDTO::set_geolinkpropagation(bool value) {
  set_has_geolinkpropagation();
  geolinkpropagation_ = value;
}

// optional int32 HeartRate = 12 [default = 0];
inline bool ExamCardPropertyDTO::has_heartrate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExamCardPropertyDTO::set_has_heartrate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExamCardPropertyDTO::clear_has_heartrate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExamCardPropertyDTO::clear_heartrate() {
  heartrate_ = 0;
  clear_has_heartrate();
}
inline ::google::protobuf::int32 ExamCardPropertyDTO::heartrate() const {
  return heartrate_;
}
inline void ExamCardPropertyDTO::set_heartrate(::google::protobuf::int32 value) {
  set_has_heartrate();
  heartrate_ = value;
}

// repeated .DTOBase Lateralities = 13;
inline int ExamCardPropertyDTO::lateralities_size() const {
  return lateralities_.size();
}
inline void ExamCardPropertyDTO::clear_lateralities() {
  lateralities_.Clear();
}
inline const ::DTOBase& ExamCardPropertyDTO::lateralities(int index) const {
  return lateralities_.Get(index);
}
inline ::DTOBase* ExamCardPropertyDTO::mutable_lateralities(int index) {
  return lateralities_.Mutable(index);
}
inline ::DTOBase* ExamCardPropertyDTO::add_lateralities() {
  return lateralities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
ExamCardPropertyDTO::lateralities() const {
  return lateralities_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
ExamCardPropertyDTO::mutable_lateralities() {
  return &lateralities_;
}

// optional string Laterality = 14;
inline bool ExamCardPropertyDTO::has_laterality() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_laterality() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExamCardPropertyDTO::clear_has_laterality() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExamCardPropertyDTO::clear_laterality() {
  if (laterality_ != &::google::protobuf::internal::kEmptyString) {
    laterality_->clear();
  }
  clear_has_laterality();
}
inline const ::std::string& ExamCardPropertyDTO::laterality() const {
  return *laterality_;
}
inline void ExamCardPropertyDTO::set_laterality(const ::std::string& value) {
  set_has_laterality();
  if (laterality_ == &::google::protobuf::internal::kEmptyString) {
    laterality_ = new ::std::string;
  }
  laterality_->assign(value);
}
inline void ExamCardPropertyDTO::set_laterality(const char* value) {
  set_has_laterality();
  if (laterality_ == &::google::protobuf::internal::kEmptyString) {
    laterality_ = new ::std::string;
  }
  laterality_->assign(value);
}
inline void ExamCardPropertyDTO::set_laterality(const char* value, size_t size) {
  set_has_laterality();
  if (laterality_ == &::google::protobuf::internal::kEmptyString) {
    laterality_ = new ::std::string;
  }
  laterality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_laterality() {
  set_has_laterality();
  if (laterality_ == &::google::protobuf::internal::kEmptyString) {
    laterality_ = new ::std::string;
  }
  return laterality_;
}
inline ::std::string* ExamCardPropertyDTO::release_laterality() {
  clear_has_laterality();
  if (laterality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = laterality_;
    laterality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_laterality(::std::string* laterality) {
  if (laterality_ != &::google::protobuf::internal::kEmptyString) {
    delete laterality_;
  }
  if (laterality) {
    set_has_laterality();
    laterality_ = laterality;
  } else {
    clear_has_laterality();
    laterality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool LateralityConflict = 15 [default = false];
inline bool ExamCardPropertyDTO::has_lateralityconflict() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_lateralityconflict() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExamCardPropertyDTO::clear_has_lateralityconflict() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExamCardPropertyDTO::clear_lateralityconflict() {
  lateralityconflict_ = false;
  clear_has_lateralityconflict();
}
inline bool ExamCardPropertyDTO::lateralityconflict() const {
  return lateralityconflict_;
}
inline void ExamCardPropertyDTO::set_lateralityconflict(bool value) {
  set_has_lateralityconflict();
  lateralityconflict_ = value;
}

// optional string Name = 16;
inline bool ExamCardPropertyDTO::has_name() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_name() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExamCardPropertyDTO::clear_has_name() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExamCardPropertyDTO::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ExamCardPropertyDTO::name() const {
  return *name_;
}
inline void ExamCardPropertyDTO::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExamCardPropertyDTO::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ExamCardPropertyDTO::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ExamCardPropertyDTO::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .GeometryDTO NamedGeometries = 17;
inline int ExamCardPropertyDTO::namedgeometries_size() const {
  return namedgeometries_.size();
}
inline void ExamCardPropertyDTO::clear_namedgeometries() {
  namedgeometries_.Clear();
}
inline const ::GeometryDTO& ExamCardPropertyDTO::namedgeometries(int index) const {
  return namedgeometries_.Get(index);
}
inline ::GeometryDTO* ExamCardPropertyDTO::mutable_namedgeometries(int index) {
  return namedgeometries_.Mutable(index);
}
inline ::GeometryDTO* ExamCardPropertyDTO::add_namedgeometries() {
  return namedgeometries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GeometryDTO >&
ExamCardPropertyDTO::namedgeometries() const {
  return namedgeometries_;
}
inline ::google::protobuf::RepeatedPtrField< ::GeometryDTO >*
ExamCardPropertyDTO::mutable_namedgeometries() {
  return &namedgeometries_;
}

// optional bool Paediatric = 18 [default = false];
inline bool ExamCardPropertyDTO::has_paediatric() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_paediatric() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExamCardPropertyDTO::clear_has_paediatric() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExamCardPropertyDTO::clear_paediatric() {
  paediatric_ = false;
  clear_has_paediatric();
}
inline bool ExamCardPropertyDTO::paediatric() const {
  return paediatric_;
}
inline void ExamCardPropertyDTO::set_paediatric(bool value) {
  set_has_paediatric();
  paediatric_ = value;
}

// repeated .DTOBase PatientOrientation = 19;
inline int ExamCardPropertyDTO::patientorientation_size() const {
  return patientorientation_.size();
}
inline void ExamCardPropertyDTO::clear_patientorientation() {
  patientorientation_.Clear();
}
inline const ::DTOBase& ExamCardPropertyDTO::patientorientation(int index) const {
  return patientorientation_.Get(index);
}
inline ::DTOBase* ExamCardPropertyDTO::mutable_patientorientation(int index) {
  return patientorientation_.Mutable(index);
}
inline ::DTOBase* ExamCardPropertyDTO::add_patientorientation() {
  return patientorientation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
ExamCardPropertyDTO::patientorientation() const {
  return patientorientation_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
ExamCardPropertyDTO::mutable_patientorientation() {
  return &patientorientation_;
}

// optional double PatientWeight = 20 [default = 0];
inline bool ExamCardPropertyDTO::has_patientweight() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_patientweight() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ExamCardPropertyDTO::clear_has_patientweight() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ExamCardPropertyDTO::clear_patientweight() {
  patientweight_ = 0;
  clear_has_patientweight();
}
inline double ExamCardPropertyDTO::patientweight() const {
  return patientweight_;
}
inline void ExamCardPropertyDTO::set_patientweight(double value) {
  set_has_patientweight();
  patientweight_ = value;
}

// optional bool PosteriorHoldBack = 21 [default = false];
inline bool ExamCardPropertyDTO::has_posteriorholdback() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_posteriorholdback() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ExamCardPropertyDTO::clear_has_posteriorholdback() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ExamCardPropertyDTO::clear_posteriorholdback() {
  posteriorholdback_ = false;
  clear_has_posteriorholdback();
}
inline bool ExamCardPropertyDTO::posteriorholdback() const {
  return posteriorholdback_;
}
inline void ExamCardPropertyDTO::set_posteriorholdback(bool value) {
  set_has_posteriorholdback();
  posteriorholdback_ = value;
}

// optional double PredictedSED = 22 [default = 0];
inline bool ExamCardPropertyDTO::has_predictedsed() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_predictedsed() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ExamCardPropertyDTO::clear_has_predictedsed() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ExamCardPropertyDTO::clear_predictedsed() {
  predictedsed_ = 0;
  clear_has_predictedsed();
}
inline double ExamCardPropertyDTO::predictedsed() const {
  return predictedsed_;
}
inline void ExamCardPropertyDTO::set_predictedsed(double value) {
  set_has_predictedsed();
  predictedsed_ = value;
}

// repeated .DTOBase ReviewRequired = 23;
inline int ExamCardPropertyDTO::reviewrequired_size() const {
  return reviewrequired_.size();
}
inline void ExamCardPropertyDTO::clear_reviewrequired() {
  reviewrequired_.Clear();
}
inline const ::DTOBase& ExamCardPropertyDTO::reviewrequired(int index) const {
  return reviewrequired_.Get(index);
}
inline ::DTOBase* ExamCardPropertyDTO::mutable_reviewrequired(int index) {
  return reviewrequired_.Mutable(index);
}
inline ::DTOBase* ExamCardPropertyDTO::add_reviewrequired() {
  return reviewrequired_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTOBase >&
ExamCardPropertyDTO::reviewrequired() const {
  return reviewrequired_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTOBase >*
ExamCardPropertyDTO::mutable_reviewrequired() {
  return &reviewrequired_;
}

// optional bool SmartType = 24 [default = false];
inline bool ExamCardPropertyDTO::has_smarttype() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_smarttype() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ExamCardPropertyDTO::clear_has_smarttype() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ExamCardPropertyDTO::clear_smarttype() {
  smarttype_ = false;
  clear_has_smarttype();
}
inline bool ExamCardPropertyDTO::smarttype() const {
  return smarttype_;
}
inline void ExamCardPropertyDTO::set_smarttype(bool value) {
  set_has_smarttype();
  smarttype_ = value;
}

// optional bool TableUsage = 25 [default = false];
inline bool ExamCardPropertyDTO::has_tableusage() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_tableusage() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ExamCardPropertyDTO::clear_has_tableusage() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ExamCardPropertyDTO::clear_tableusage() {
  tableusage_ = false;
  clear_has_tableusage();
}
inline bool ExamCardPropertyDTO::tableusage() const {
  return tableusage_;
}
inline void ExamCardPropertyDTO::set_tableusage(bool value) {
  set_has_tableusage();
  tableusage_ = value;
}

// optional string WeightUnit = 26;
inline bool ExamCardPropertyDTO::has_weightunit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ExamCardPropertyDTO::set_has_weightunit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ExamCardPropertyDTO::clear_has_weightunit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ExamCardPropertyDTO::clear_weightunit() {
  if (weightunit_ != &::google::protobuf::internal::kEmptyString) {
    weightunit_->clear();
  }
  clear_has_weightunit();
}
inline const ::std::string& ExamCardPropertyDTO::weightunit() const {
  return *weightunit_;
}
inline void ExamCardPropertyDTO::set_weightunit(const ::std::string& value) {
  set_has_weightunit();
  if (weightunit_ == &::google::protobuf::internal::kEmptyString) {
    weightunit_ = new ::std::string;
  }
  weightunit_->assign(value);
}
inline void ExamCardPropertyDTO::set_weightunit(const char* value) {
  set_has_weightunit();
  if (weightunit_ == &::google::protobuf::internal::kEmptyString) {
    weightunit_ = new ::std::string;
  }
  weightunit_->assign(value);
}
inline void ExamCardPropertyDTO::set_weightunit(const char* value, size_t size) {
  set_has_weightunit();
  if (weightunit_ == &::google::protobuf::internal::kEmptyString) {
    weightunit_ = new ::std::string;
  }
  weightunit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExamCardPropertyDTO::mutable_weightunit() {
  set_has_weightunit();
  if (weightunit_ == &::google::protobuf::internal::kEmptyString) {
    weightunit_ = new ::std::string;
  }
  return weightunit_;
}
inline ::std::string* ExamCardPropertyDTO::release_weightunit() {
  clear_has_weightunit();
  if (weightunit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weightunit_;
    weightunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExamCardPropertyDTO::set_allocated_weightunit(::std::string* weightunit) {
  if (weightunit_ != &::google::protobuf::internal::kEmptyString) {
    delete weightunit_;
  }
  if (weightunit) {
    set_has_weightunit();
    weightunit_ = weightunit;
  } else {
    clear_has_weightunit();
    weightunit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GeometryDTO

// -------------------------------------------------------------------

// IAdapter

// -------------------------------------------------------------------

// Object

// -------------------------------------------------------------------

// ScanSetDTO

// repeated .ElementBase ChildElements = 1;
inline int ScanSetDTO::childelements_size() const {
  return childelements_.size();
}
inline void ScanSetDTO::clear_childelements() {
  childelements_.Clear();
}
inline const ::ElementBase& ScanSetDTO::childelements(int index) const {
  return childelements_.Get(index);
}
inline ::ElementBase* ScanSetDTO::mutable_childelements(int index) {
  return childelements_.Mutable(index);
}
inline ::ElementBase* ScanSetDTO::add_childelements() {
  return childelements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ElementBase >&
ScanSetDTO::childelements() const {
  return childelements_;
}
inline ::google::protobuf::RepeatedPtrField< ::ElementBase >*
ScanSetDTO::mutable_childelements() {
  return &childelements_;
}

// optional bool EditMode = 2 [default = false];
inline bool ScanSetDTO::has_editmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanSetDTO::set_has_editmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanSetDTO::clear_has_editmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanSetDTO::clear_editmode() {
  editmode_ = false;
  clear_has_editmode();
}
inline bool ScanSetDTO::editmode() const {
  return editmode_;
}
inline void ScanSetDTO::set_editmode(bool value) {
  set_has_editmode();
  editmode_ = value;
}

// -------------------------------------------------------------------

// SelectableItemDTO

// optional string Caption = 1;
inline bool SelectableItemDTO::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectableItemDTO::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectableItemDTO::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectableItemDTO::clear_caption() {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    caption_->clear();
  }
  clear_has_caption();
}
inline const ::std::string& SelectableItemDTO::caption() const {
  return *caption_;
}
inline void SelectableItemDTO::set_caption(const ::std::string& value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void SelectableItemDTO::set_caption(const char* value) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(value);
}
inline void SelectableItemDTO::set_caption(const char* value, size_t size) {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  caption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelectableItemDTO::mutable_caption() {
  set_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    caption_ = new ::std::string;
  }
  return caption_;
}
inline ::std::string* SelectableItemDTO::release_caption() {
  clear_has_caption();
  if (caption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caption_;
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelectableItemDTO::set_allocated_caption(::std::string* caption) {
  if (caption_ != &::google::protobuf::internal::kEmptyString) {
    delete caption_;
  }
  if (caption) {
    set_has_caption();
    caption_ = caption;
  } else {
    clear_has_caption();
    caption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ID = 2;
inline bool SelectableItemDTO::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectableItemDTO::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectableItemDTO::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectableItemDTO::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SelectableItemDTO::id() const {
  return *id_;
}
inline void SelectableItemDTO::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SelectableItemDTO::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SelectableItemDTO::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SelectableItemDTO::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SelectableItemDTO::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SelectableItemDTO::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsInConflict = 3 [default = false];
inline bool SelectableItemDTO::has_isinconflict() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectableItemDTO::set_has_isinconflict() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectableItemDTO::clear_has_isinconflict() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectableItemDTO::clear_isinconflict() {
  isinconflict_ = false;
  clear_has_isinconflict();
}
inline bool SelectableItemDTO::isinconflict() const {
  return isinconflict_;
}
inline void SelectableItemDTO::set_isinconflict(bool value) {
  set_has_isinconflict();
  isinconflict_ = value;
}

// optional bool IsSelected = 4 [default = false];
inline bool SelectableItemDTO::has_isselected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SelectableItemDTO::set_has_isselected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SelectableItemDTO::clear_has_isselected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SelectableItemDTO::clear_isselected() {
  isselected_ = false;
  clear_has_isselected();
}
inline bool SelectableItemDTO::isselected() const {
  return isselected_;
}
inline void SelectableItemDTO::set_isselected(bool value) {
  set_has_isselected();
  isselected_ = value;
}

// -------------------------------------------------------------------

// StepDTO

// -------------------------------------------------------------------

// TransferPropertyDTO

// optional bool EnablePushToWorkstation = 1 [default = false];
inline bool TransferPropertyDTO::has_enablepushtoworkstation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferPropertyDTO::set_has_enablepushtoworkstation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferPropertyDTO::clear_has_enablepushtoworkstation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferPropertyDTO::clear_enablepushtoworkstation() {
  enablepushtoworkstation_ = false;
  clear_has_enablepushtoworkstation();
}
inline bool TransferPropertyDTO::enablepushtoworkstation() const {
  return enablepushtoworkstation_;
}
inline void TransferPropertyDTO::set_enablepushtoworkstation(bool value) {
  set_has_enablepushtoworkstation();
  enablepushtoworkstation_ = value;
}

// optional bool IsCandidateForTransfer = 2 [default = false];
inline bool TransferPropertyDTO::has_iscandidatefortransfer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferPropertyDTO::set_has_iscandidatefortransfer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferPropertyDTO::clear_has_iscandidatefortransfer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferPropertyDTO::clear_iscandidatefortransfer() {
  iscandidatefortransfer_ = false;
  clear_has_iscandidatefortransfer();
}
inline bool TransferPropertyDTO::iscandidatefortransfer() const {
  return iscandidatefortransfer_;
}
inline void TransferPropertyDTO::set_iscandidatefortransfer(bool value) {
  set_has_iscandidatefortransfer();
  iscandidatefortransfer_ = value;
}

// optional bool PushToWorkstation = 3 [default = false];
inline bool TransferPropertyDTO::has_pushtoworkstation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferPropertyDTO::set_has_pushtoworkstation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferPropertyDTO::clear_has_pushtoworkstation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferPropertyDTO::clear_pushtoworkstation() {
  pushtoworkstation_ = false;
  clear_has_pushtoworkstation();
}
inline bool TransferPropertyDTO::pushtoworkstation() const {
  return pushtoworkstation_;
}
inline void TransferPropertyDTO::set_pushtoworkstation(bool value) {
  set_has_pushtoworkstation();
  pushtoworkstation_ = value;
}

// optional .SortOrder SliceOrder = 4 [default = ASCENDING];
inline bool TransferPropertyDTO::has_sliceorder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransferPropertyDTO::set_has_sliceorder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransferPropertyDTO::clear_has_sliceorder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransferPropertyDTO::clear_sliceorder() {
  sliceorder_ = 0;
  clear_has_sliceorder();
}
inline ::SortOrder TransferPropertyDTO::sliceorder() const {
  return static_cast< ::SortOrder >(sliceorder_);
}
inline void TransferPropertyDTO::set_sliceorder(::SortOrder value) {
  assert(::SortOrder_IsValid(value));
  set_has_sliceorder();
  sliceorder_ = value;
}

// repeated .SortAttributes SortingAttributes = 5;
inline int TransferPropertyDTO::sortingattributes_size() const {
  return sortingattributes_.size();
}
inline void TransferPropertyDTO::clear_sortingattributes() {
  sortingattributes_.Clear();
}
inline ::SortAttributes TransferPropertyDTO::sortingattributes(int index) const {
  return static_cast< ::SortAttributes >(sortingattributes_.Get(index));
}
inline void TransferPropertyDTO::set_sortingattributes(int index, ::SortAttributes value) {
  assert(::SortAttributes_IsValid(value));
  sortingattributes_.Set(index, value);
}
inline void TransferPropertyDTO::add_sortingattributes(::SortAttributes value) {
  assert(::SortAttributes_IsValid(value));
  sortingattributes_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
TransferPropertyDTO::sortingattributes() const {
  return sortingattributes_;
}
inline ::google::protobuf::RepeatedField<int>*
TransferPropertyDTO::mutable_sortingattributes() {
  return &sortingattributes_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SortAttributes>() {
  return ::SortAttributes_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SortOrder>() {
  return ::SortOrder_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ECViewmodel_2eproto__INCLUDED
