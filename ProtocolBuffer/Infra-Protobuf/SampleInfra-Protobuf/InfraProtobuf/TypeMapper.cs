#region  Copyright 2014 Koninklijke Philips N.V.
// 
// All rights are reserved. Reproduction or transmission in whole or in part, in
// any form or by any means, electronic, mechanical or otherwise, is prohibited
// without the prior written permission of the copyright owner.
#endregion
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Philips.PmsMR.Platform.Logging;

namespace Philips.PmsMR.Protobuf.ModelReflection
{
    /// <summary>
    /// TypeMapper provides storage for mapping from protobuf integer ids to 
    /// .NET types based on found class and field names in the DataModel.
    /// </summary>
    /// <remarks>
    /// <p>
    /// The actual reflection work is done outside this class,
    /// we just take care of background work synchronization and data storage and acts as a facade to the mappings.
    /// </p>
    /// <p>
    /// The reflection is lengthy task, so this class should be created as early as possible,
    /// to start working on the background. To use the reflected results,
    /// a <see cref="Philips.PmsMR.Protobuf.ModelReflection.Modeler">modeler</see> instance is needed to convert the types into a protobuf datamodel.
    /// </p>
    /// </remarks>
    public class TypeMapper
    {
        /// <summary>
        /// Initializing ctor.
        /// </summary>
        /// <remarks>
        /// The constructor starts the background reflection immediately.
        /// The provided datamodel identifier is used to reflect
        /// a particular namespace for plain old data (POD) classes,
        /// which are, together with their simple public fields, associated with integer ids
        /// that are generated from the string names of those entries.
        /// </remarks>
        /// <param name="tag">Data model identifier</param>
        public TypeMapper(DataModel.IDataModelTag tag)
        {
            if ((tag.DataModelOptions & Philips.PmsMR.Protobuf.DataModel.DataModelOptionTypes.GeneratedFromProtoFile) != 0)
            {
                // Datamodel is defined by a .proto file, and C# classes have been autogenerated with the ProtoGen program.
                CreateFromGenerated(tag);
            }
            else
            {
                var namespaceTag = tag as DataModel.INamespaceTag;

                if (namespaceTag == null)
                {
                    throw new ArgumentException("DataModelOptionTypes indicates a namespaced data model, but cast to INamespaceTag failed", "tag");
                }

                // Datamodel is defined by C# classes.
                CreateFromReflection(namespaceTag);
            }
        }

        /// <summary>
        /// Returns the reflected mapping from namespace-integer id to .NET types.
        /// </summary>
        /// <remarks>
        /// Calling this immediately after accessing the instance for the first time may take a long time.
        /// If the mapping fails, mapping result properties will be null (maps not available).
        /// </remarks>
        /// <exception cref="ModelReflectionException">If the mapping fails with known model violations, exception can be thrown.</exception>
        public IMappingResult Result
        {
            get
            {
                lock (syncBlock) {
                    while (mappingResult == null)
                    {
                        Monitor.Wait(syncBlock);
                    }
                }
                if (mappingException != null)
                {
                    throw mappingException;
                }
                return mappingResult;
            }
        }

        /// <summary>
        /// Datamodel factory access.
        /// </summary>
        public Factory Factory
        {
            get {
                return new Factory(Result);
            }
        }

        /// <summary>
        /// Modeler access for normal cases where the modeler does not need customizations.
        /// </summary>
        /// <returns></returns>
        public Modeler DefaultModeler 
        {
            get
            {
                lock (syncBlock) {
                    while (modeler == null && modelerBeingCreated)
                    {
                        Monitor.Wait(syncBlock);
                    }
                    if (modeler != null)
                    {
                        return modeler;
                    }

                    modelerBeingCreated = true;
                }

                Modeler tmpModeler = null;
                try
                {
                    tmpModeler = new Modeler();
                    tmpModeler.CreateModel(this);
                    tmpModeler.PrecompileModels();
                }
                finally
                {
                    lock (syncBlock)
                    {
                        modelerBeingCreated = false;
                        modeler = tmpModeler;
                        Monitor.PulseAll(syncBlock);
                    }
                }
                return tmpModeler;
            }
        }

        private void CreateFromGenerated(DataModel.IDataModelTag dataModelTag)
        {
            mappingResult = new ProtoFileMappingResult(dataModelTag as DataModel.IProtoFileTag);
        }

        private void CreateFromReflection(DataModel.INamespaceTag namespaceTag)
        {
            var map = new Dictionary<NamespaceId, IList<Type>>();
            var derivedChain = new Dictionary<Type, IEnumerable<Type>>();
            ReflectedMappingResult result = null;
            Action act = () =>
            {
                try
                {
                    var populator = new TypePopulator(namespaceTag);
                    populator.CreateMapping(namespaceTag.GetTypes(), map, derivedChain);
                    result = new ReflectedMappingResult(map, derivedChain, namespaceTag);
                }
                catch (ModelReflectionException modelException)
                {
                    lock (syncBlock)
                    {
                        mappingException = modelException;
                    }
                }
                catch (Exception e)
                {
                    logging.Error("Unknown exception encountered during model reflection: " + e.ToString());
                    throw;
                }
                finally
                {
                    lock (syncBlock)
                    {
                        this.mappingResult = result ?? new ReflectedMappingResult();
                        Monitor.PulseAll(syncBlock);
                    }
                }
            };

            // Populate the map in the background to prevent a lengthy wait - reflection can be slow
            act.BeginInvoke(act.EndInvoke, null);
        }


        private readonly object syncBlock = new object();
        private IMappingResult mappingResult;
        private Exception mappingException;
        private Modeler modeler;
        private bool modelerBeingCreated;

        private static readonly SystemMessage logging = new SystemMessage("Protobuf", "TypeMapper");
    }
}
