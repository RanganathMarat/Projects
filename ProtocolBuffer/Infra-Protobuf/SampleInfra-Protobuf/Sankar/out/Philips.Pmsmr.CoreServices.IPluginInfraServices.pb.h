// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Philips.Pmsmr.CoreServices.IPluginInfraServices.proto

#ifndef PROTOBUF_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto__INCLUDED
#define PROTOBUF_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bcl.pb.h"
// @@protoc_insertion_point(includes)

namespace Philips {
namespace Pmsmr {
namespace CoreServices {
namespace IPluginInfraServices {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

class AuditLogEntry;
class AuditLogEntryRequestMessage;
class AuditLogEntryResponseMessage;
class CreateNewSeriesRequestMessage;
class CreateNewSeriesResponseMessage;
class FaultResponseMessage;
class GetInstanceRequestMessage;
class GetInstanceResponseMessage;
class LicenseInformation;
class LogEntriesRequestMessage;
class LogEntriesResponseMessage;
class LogEntry;
class PatientIdentification;
class QueryLicensesRequestMessage;
class QueryLicensesResponseMessage;
class QueryVersionRequestMessage;
class QueryVersionResponseMessage;
class StoreInstanceRequestMessage;
class StoreInstanceResponseMessage;

enum MessageId {
  AuditLogEntryId = 135620956,
  AuditLogEntryRequestMessageId = 76931800,
  AuditLogEntryResponseMessageId = 261504017,
  CreateNewSeriesRequestMessageId = 264094664,
  CreateNewSeriesResponseMessageId = 15332642,
  FaultResponseMessageId = 33712978,
  GetInstanceRequestMessageId = 287996500,
  GetInstanceResponseMessageId = 346806853,
  LicenseInformationId = 290725662,
  LogEntriesRequestMessageId = 132477858,
  LogEntriesResponseMessageId = 434761467,
  LogEntryId = 513793492,
  PatientIdentificationId = 324203170,
  QueryLicensesRequestMessageId = 341592833,
  QueryLicensesResponseMessageId = 171457479,
  QueryVersionRequestMessageId = 456676121,
  QueryVersionResponseMessageId = 2497979,
  StoreInstanceRequestMessageId = 224928297,
  StoreInstanceResponseMessageId = 50922701
};
bool MessageId_IsValid(int value);
const MessageId MessageId_MIN = QueryVersionResponseMessageId;
const MessageId MessageId_MAX = LogEntryId;
const int MessageId_ARRAYSIZE = MessageId_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageId_descriptor();
inline const ::std::string& MessageId_Name(MessageId value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageId_descriptor(), value);
}
inline bool MessageId_Parse(
    const ::std::string& name, MessageId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageId>(
    MessageId_descriptor(), name, value);
}
enum AuditTrailActionType {
  UnknownLoggingAuditTrailActionType = 0,
  AuditTrailActionTypeModify = 24,
  AuditTrailActionTypeAccess = 63,
  AuditTrailActionTypeCreate = 532,
  AuditTrailActionTypeDelete = 844
};
bool AuditTrailActionType_IsValid(int value);
const AuditTrailActionType AuditTrailActionType_MIN = UnknownLoggingAuditTrailActionType;
const AuditTrailActionType AuditTrailActionType_MAX = AuditTrailActionTypeDelete;
const int AuditTrailActionType_ARRAYSIZE = AuditTrailActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuditTrailActionType_descriptor();
inline const ::std::string& AuditTrailActionType_Name(AuditTrailActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuditTrailActionType_descriptor(), value);
}
inline bool AuditTrailActionType_Parse(
    const ::std::string& name, AuditTrailActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuditTrailActionType>(
    AuditTrailActionType_descriptor(), name, value);
}
enum LoggingSeverityType {
  UnknownLoggingSeverityType = 0,
  LoggingSeverityTypeInformation = 1,
  LoggingSeverityTypeWarning = 2,
  LoggingSeverityTypeError = 622,
  LoggingSeverityTypeFatal = 34522
};
bool LoggingSeverityType_IsValid(int value);
const LoggingSeverityType LoggingSeverityType_MIN = UnknownLoggingSeverityType;
const LoggingSeverityType LoggingSeverityType_MAX = LoggingSeverityTypeFatal;
const int LoggingSeverityType_ARRAYSIZE = LoggingSeverityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoggingSeverityType_descriptor();
inline const ::std::string& LoggingSeverityType_Name(LoggingSeverityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoggingSeverityType_descriptor(), value);
}
inline bool LoggingSeverityType_Parse(
    const ::std::string& name, LoggingSeverityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggingSeverityType>(
    LoggingSeverityType_descriptor(), name, value);
}
enum LoggingType {
  UnknownLoggingType = 0,
  LoggingTypeDevelopment = 1,
  LoggingTypeTrace = 2,
  LoggingTypeUtilization = 24,
  LoggingTypeService = 32
};
bool LoggingType_IsValid(int value);
const LoggingType LoggingType_MIN = UnknownLoggingType;
const LoggingType LoggingType_MAX = LoggingTypeService;
const int LoggingType_ARRAYSIZE = LoggingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoggingType_descriptor();
inline const ::std::string& LoggingType_Name(LoggingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoggingType_descriptor(), value);
}
inline bool LoggingType_Parse(
    const ::std::string& name, LoggingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoggingType>(
    LoggingType_descriptor(), name, value);
}
// ===================================================================

class AuditLogEntry : public ::google::protobuf::Message {
 public:
  AuditLogEntry();
  virtual ~AuditLogEntry();

  AuditLogEntry(const AuditLogEntry& from);

  inline AuditLogEntry& operator=(const AuditLogEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuditLogEntry& default_instance();

  void Swap(AuditLogEntry* other);

  // implements Message ----------------------------------------------

  AuditLogEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuditLogEntry& from);
  void MergeFrom(const AuditLogEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string LocalUser = 189969938;
  inline bool has_localuser() const;
  inline void clear_localuser();
  static const int kLocalUserFieldNumber = 189969938;
  inline const ::std::string& localuser() const;
  inline void set_localuser(const ::std::string& value);
  inline void set_localuser(const char* value);
  inline void set_localuser(const char* value, size_t size);
  inline ::std::string* mutable_localuser();
  inline ::std::string* release_localuser();
  inline void set_allocated_localuser(::std::string* localuser);

  // optional string MediaId = 195662816;
  inline bool has_mediaid() const;
  inline void clear_mediaid();
  static const int kMediaIdFieldNumber = 195662816;
  inline const ::std::string& mediaid() const;
  inline void set_mediaid(const ::std::string& value);
  inline void set_mediaid(const char* value);
  inline void set_mediaid(const char* value, size_t size);
  inline ::std::string* mutable_mediaid();
  inline ::std::string* release_mediaid();
  inline void set_allocated_mediaid(::std::string* mediaid);

  // optional string Cuid = 240968192;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 240968192;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  inline ::std::string* release_cuid();
  inline void set_allocated_cuid(::std::string* cuid);

  // optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditTrailActionType ObjectAction = 318973292;
  inline bool has_objectaction() const;
  inline void clear_objectaction();
  static const int kObjectActionFieldNumber = 318973292;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType objectaction() const;
  inline void set_objectaction(::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType value);

  // optional string MediaType = 327435043;
  inline bool has_mediatype() const;
  inline void clear_mediatype();
  static const int kMediaTypeFieldNumber = 327435043;
  inline const ::std::string& mediatype() const;
  inline void set_mediatype(const ::std::string& value);
  inline void set_mediatype(const char* value);
  inline void set_mediatype(const char* value, size_t size);
  inline ::std::string* mutable_mediatype();
  inline ::std::string* release_mediatype();
  inline void set_allocated_mediatype(::std::string* mediatype);

  // optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.PatientIdentification Patient = 358715586;
  inline bool has_patient() const;
  inline void clear_patient();
  static const int kPatientFieldNumber = 358715586;
  inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification& patient() const;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* mutable_patient();
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* release_patient();
  inline void set_allocated_patient(::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* patient);

  // optional string IpAddress = 380234388;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpAddressFieldNumber = 380234388;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string ApplicationEntityTitle = 422344688;
  inline bool has_applicationentitytitle() const;
  inline void clear_applicationentitytitle();
  static const int kApplicationEntityTitleFieldNumber = 422344688;
  inline const ::std::string& applicationentitytitle() const;
  inline void set_applicationentitytitle(const ::std::string& value);
  inline void set_applicationentitytitle(const char* value);
  inline void set_applicationentitytitle(const char* value, size_t size);
  inline ::std::string* mutable_applicationentitytitle();
  inline ::std::string* release_applicationentitytitle();
  inline void set_allocated_applicationentitytitle(::std::string* applicationentitytitle);

  // optional string Suid = 446571201;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 446571201;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // optional int32 InstancesSent = 456452303;
  inline bool has_instancessent() const;
  inline void clear_instancessent();
  static const int kInstancesSentFieldNumber = 456452303;
  inline ::google::protobuf::int32 instancessent() const;
  inline void set_instancessent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditLogEntry)
 private:
  inline void set_has_localuser();
  inline void clear_has_localuser();
  inline void set_has_mediaid();
  inline void clear_has_mediaid();
  inline void set_has_cuid();
  inline void clear_has_cuid();
  inline void set_has_objectaction();
  inline void clear_has_objectaction();
  inline void set_has_mediatype();
  inline void clear_has_mediatype();
  inline void set_has_patient();
  inline void clear_has_patient();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_applicationentitytitle();
  inline void clear_has_applicationentitytitle();
  inline void set_has_suid();
  inline void clear_has_suid();
  inline void set_has_instancessent();
  inline void clear_has_instancessent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* localuser_;
  ::std::string* mediaid_;
  ::std::string* cuid_;
  ::std::string* mediatype_;
  ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* patient_;
  ::std::string* ipaddress_;
  int objectaction_;
  ::google::protobuf::int32 instancessent_;
  ::std::string* applicationentitytitle_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static AuditLogEntry* default_instance_;
};
// -------------------------------------------------------------------

class AuditLogEntryRequestMessage : public ::google::protobuf::Message {
 public:
  AuditLogEntryRequestMessage();
  virtual ~AuditLogEntryRequestMessage();

  AuditLogEntryRequestMessage(const AuditLogEntryRequestMessage& from);

  inline AuditLogEntryRequestMessage& operator=(const AuditLogEntryRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuditLogEntryRequestMessage& default_instance();

  void Swap(AuditLogEntryRequestMessage* other);

  // implements Message ----------------------------------------------

  AuditLogEntryRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuditLogEntryRequestMessage& from);
  void MergeFrom(const AuditLogEntryRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditLogEntry AuditLog = 171435145;
  inline bool has_auditlog() const;
  inline void clear_auditlog();
  static const int kAuditLogFieldNumber = 171435145;
  inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry& auditlog() const;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* mutable_auditlog();
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* release_auditlog();
  inline void set_allocated_auditlog(::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* auditlog);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditLogEntryRequestMessage)
 private:
  inline void set_has_auditlog();
  inline void clear_has_auditlog();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* auditlog_;
  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static AuditLogEntryRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuditLogEntryResponseMessage : public ::google::protobuf::Message {
 public:
  AuditLogEntryResponseMessage();
  virtual ~AuditLogEntryResponseMessage();

  AuditLogEntryResponseMessage(const AuditLogEntryResponseMessage& from);

  inline AuditLogEntryResponseMessage& operator=(const AuditLogEntryResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuditLogEntryResponseMessage& default_instance();

  void Swap(AuditLogEntryResponseMessage* other);

  // implements Message ----------------------------------------------

  AuditLogEntryResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuditLogEntryResponseMessage& from);
  void MergeFrom(const AuditLogEntryResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditLogEntryResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static AuditLogEntryResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class CreateNewSeriesRequestMessage : public ::google::protobuf::Message {
 public:
  CreateNewSeriesRequestMessage();
  virtual ~CreateNewSeriesRequestMessage();

  CreateNewSeriesRequestMessage(const CreateNewSeriesRequestMessage& from);

  inline CreateNewSeriesRequestMessage& operator=(const CreateNewSeriesRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNewSeriesRequestMessage& default_instance();

  void Swap(CreateNewSeriesRequestMessage* other);

  // implements Message ----------------------------------------------

  CreateNewSeriesRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNewSeriesRequestMessage& from);
  void MergeFrom(const CreateNewSeriesRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string StudyUid = 32159375;
  inline bool has_studyuid() const;
  inline void clear_studyuid();
  static const int kStudyUidFieldNumber = 32159375;
  inline const ::std::string& studyuid() const;
  inline void set_studyuid(const ::std::string& value);
  inline void set_studyuid(const char* value);
  inline void set_studyuid(const char* value, size_t size);
  inline ::std::string* mutable_studyuid();
  inline ::std::string* release_studyuid();
  inline void set_allocated_studyuid(::std::string* studyuid);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // optional int32 TotalNumberOfInstances = 499099872;
  inline bool has_totalnumberofinstances() const;
  inline void clear_totalnumberofinstances();
  static const int kTotalNumberOfInstancesFieldNumber = 499099872;
  inline ::google::protobuf::int32 totalnumberofinstances() const;
  inline void set_totalnumberofinstances(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.CreateNewSeriesRequestMessage)
 private:
  inline void set_has_studyuid();
  inline void clear_has_studyuid();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();
  inline void set_has_totalnumberofinstances();
  inline void clear_has_totalnumberofinstances();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* studyuid_;
  ::bcl::Guid* requesttoken_;
  ::google::protobuf::int32 totalnumberofinstances_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static CreateNewSeriesRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class CreateNewSeriesResponseMessage : public ::google::protobuf::Message {
 public:
  CreateNewSeriesResponseMessage();
  virtual ~CreateNewSeriesResponseMessage();

  CreateNewSeriesResponseMessage(const CreateNewSeriesResponseMessage& from);

  inline CreateNewSeriesResponseMessage& operator=(const CreateNewSeriesResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNewSeriesResponseMessage& default_instance();

  void Swap(CreateNewSeriesResponseMessage* other);

  // implements Message ----------------------------------------------

  CreateNewSeriesResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNewSeriesResponseMessage& from);
  void MergeFrom(const CreateNewSeriesResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // optional string SeriesUid = 455686289;
  inline bool has_seriesuid() const;
  inline void clear_seriesuid();
  static const int kSeriesUidFieldNumber = 455686289;
  inline const ::std::string& seriesuid() const;
  inline void set_seriesuid(const ::std::string& value);
  inline void set_seriesuid(const char* value);
  inline void set_seriesuid(const char* value, size_t size);
  inline ::std::string* mutable_seriesuid();
  inline ::std::string* release_seriesuid();
  inline void set_allocated_seriesuid(::std::string* seriesuid);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.CreateNewSeriesResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();
  inline void set_has_seriesuid();
  inline void clear_has_seriesuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;
  ::std::string* seriesuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static CreateNewSeriesResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class FaultResponseMessage : public ::google::protobuf::Message {
 public:
  FaultResponseMessage();
  virtual ~FaultResponseMessage();

  FaultResponseMessage(const FaultResponseMessage& from);

  inline FaultResponseMessage& operator=(const FaultResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaultResponseMessage& default_instance();

  void Swap(FaultResponseMessage* other);

  // implements Message ----------------------------------------------

  FaultResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FaultResponseMessage& from);
  void MergeFrom(const FaultResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // optional string Description = 526552083;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 526552083;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.FaultResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;
  ::std::string* description_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static FaultResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class GetInstanceRequestMessage : public ::google::protobuf::Message {
 public:
  GetInstanceRequestMessage();
  virtual ~GetInstanceRequestMessage();

  GetInstanceRequestMessage(const GetInstanceRequestMessage& from);

  inline GetInstanceRequestMessage& operator=(const GetInstanceRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstanceRequestMessage& default_instance();

  void Swap(GetInstanceRequestMessage* other);

  // implements Message ----------------------------------------------

  GetInstanceRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstanceRequestMessage& from);
  void MergeFrom(const GetInstanceRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SeriesRoid = 61223739;
  inline bool has_seriesroid() const;
  inline void clear_seriesroid();
  static const int kSeriesRoidFieldNumber = 61223739;
  inline const ::std::string& seriesroid() const;
  inline void set_seriesroid(const ::std::string& value);
  inline void set_seriesroid(const char* value);
  inline void set_seriesroid(const char* value, size_t size);
  inline ::std::string* mutable_seriesroid();
  inline ::std::string* release_seriesroid();
  inline void set_allocated_seriesroid(::std::string* seriesroid);

  // optional int32 IndexNumber = 71782239;
  inline bool has_indexnumber() const;
  inline void clear_indexnumber();
  static const int kIndexNumberFieldNumber = 71782239;
  inline ::google::protobuf::int32 indexnumber() const;
  inline void set_indexnumber(::google::protobuf::int32 value);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.GetInstanceRequestMessage)
 private:
  inline void set_has_seriesroid();
  inline void clear_has_seriesroid();
  inline void set_has_indexnumber();
  inline void clear_has_indexnumber();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seriesroid_;
  ::bcl::Guid* requesttoken_;
  ::google::protobuf::int32 indexnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static GetInstanceRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class GetInstanceResponseMessage : public ::google::protobuf::Message {
 public:
  GetInstanceResponseMessage();
  virtual ~GetInstanceResponseMessage();

  GetInstanceResponseMessage(const GetInstanceResponseMessage& from);

  inline GetInstanceResponseMessage& operator=(const GetInstanceResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstanceResponseMessage& default_instance();

  void Swap(GetInstanceResponseMessage* other);

  // implements Message ----------------------------------------------

  GetInstanceResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstanceResponseMessage& from);
  void MergeFrom(const GetInstanceResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes DicomInstance = 223999527;
  inline bool has_dicominstance() const;
  inline void clear_dicominstance();
  static const int kDicomInstanceFieldNumber = 223999527;
  inline const ::std::string& dicominstance() const;
  inline void set_dicominstance(const ::std::string& value);
  inline void set_dicominstance(const char* value);
  inline void set_dicominstance(const void* value, size_t size);
  inline ::std::string* mutable_dicominstance();
  inline ::std::string* release_dicominstance();
  inline void set_allocated_dicominstance(::std::string* dicominstance);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // optional int32 TotalNumberOfInstances = 499099872;
  inline bool has_totalnumberofinstances() const;
  inline void clear_totalnumberofinstances();
  static const int kTotalNumberOfInstancesFieldNumber = 499099872;
  inline ::google::protobuf::int32 totalnumberofinstances() const;
  inline void set_totalnumberofinstances(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.GetInstanceResponseMessage)
 private:
  inline void set_has_dicominstance();
  inline void clear_has_dicominstance();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();
  inline void set_has_totalnumberofinstances();
  inline void clear_has_totalnumberofinstances();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dicominstance_;
  ::bcl::Guid* requesttoken_;
  ::google::protobuf::int32 totalnumberofinstances_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static GetInstanceResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class LicenseInformation : public ::google::protobuf::Message {
 public:
  LicenseInformation();
  virtual ~LicenseInformation();

  LicenseInformation(const LicenseInformation& from);

  inline LicenseInformation& operator=(const LicenseInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LicenseInformation& default_instance();

  void Swap(LicenseInformation* other);

  // implements Message ----------------------------------------------

  LicenseInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LicenseInformation& from);
  void MergeFrom(const LicenseInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ValidLicenseAvailable = 419454084;
  inline bool has_validlicenseavailable() const;
  inline void clear_validlicenseavailable();
  static const int kValidLicenseAvailableFieldNumber = 419454084;
  inline bool validlicenseavailable() const;
  inline void set_validlicenseavailable(bool value);

  // optional string Option = 527329630;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 527329630;
  inline const ::std::string& option() const;
  inline void set_option(const ::std::string& value);
  inline void set_option(const char* value);
  inline void set_option(const char* value, size_t size);
  inline ::std::string* mutable_option();
  inline ::std::string* release_option();
  inline void set_allocated_option(::std::string* option);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.LicenseInformation)
 private:
  inline void set_has_validlicenseavailable();
  inline void clear_has_validlicenseavailable();
  inline void set_has_option();
  inline void clear_has_option();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* option_;
  bool validlicenseavailable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static LicenseInformation* default_instance_;
};
// -------------------------------------------------------------------

class LogEntriesRequestMessage : public ::google::protobuf::Message {
 public:
  LogEntriesRequestMessage();
  virtual ~LogEntriesRequestMessage();

  LogEntriesRequestMessage(const LogEntriesRequestMessage& from);

  inline LogEntriesRequestMessage& operator=(const LogEntriesRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntriesRequestMessage& default_instance();

  void Swap(LogEntriesRequestMessage* other);

  // implements Message ----------------------------------------------

  LogEntriesRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEntriesRequestMessage& from);
  void MergeFrom(const LogEntriesRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // repeated .Philips.Pmsmr.CoreServices.IPluginInfraServices.LogEntry EntriesToBeLogged = 526924394;
  inline int entriestobelogged_size() const;
  inline void clear_entriestobelogged();
  static const int kEntriesToBeLoggedFieldNumber = 526924394;
  inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry& entriestobelogged(int index) const;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry* mutable_entriestobelogged(int index);
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry* add_entriestobelogged();
  inline const ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry >&
      entriestobelogged() const;
  inline ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry >*
      mutable_entriestobelogged();

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.LogEntriesRequestMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;
  ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry > entriestobelogged_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static LogEntriesRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogEntriesResponseMessage : public ::google::protobuf::Message {
 public:
  LogEntriesResponseMessage();
  virtual ~LogEntriesResponseMessage();

  LogEntriesResponseMessage(const LogEntriesResponseMessage& from);

  inline LogEntriesResponseMessage& operator=(const LogEntriesResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntriesResponseMessage& default_instance();

  void Swap(LogEntriesResponseMessage* other);

  // implements Message ----------------------------------------------

  LogEntriesResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEntriesResponseMessage& from);
  void MergeFrom(const LogEntriesResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.LogEntriesResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static LogEntriesResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogEntry : public ::google::protobuf::Message {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  void Swap(LogEntry* other);

  // implements Message ----------------------------------------------

  LogEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 OriginatorId = 1;
  inline bool has_originatorid() const;
  inline void clear_originatorid();
  static const int kOriginatorIdFieldNumber = 1;
  inline ::google::protobuf::int32 originatorid() const;
  inline void set_originatorid(::google::protobuf::int32 value);

  // optional string EventId = 2;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 2;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  inline void set_allocated_eventid(::std::string* eventid);

  // optional int64 TimeStamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string Description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string AdditionalInfo = 5;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 5;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  inline void set_allocated_additionalinfo(::std::string* additionalinfo);

  // optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.LoggingSeverityType Severity = 6;
  inline bool has_severity() const;
  inline void clear_severity();
  static const int kSeverityFieldNumber = 6;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType severity() const;
  inline void set_severity(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType value);

  // optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.LoggingType Type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType type() const;
  inline void set_type(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType value);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.LogEntry)
 private:
  inline void set_has_originatorid();
  inline void clear_has_originatorid();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventid_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 originatorid_;
  int severity_;
  ::std::string* description_;
  ::std::string* additionalinfo_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static LogEntry* default_instance_;
};
// -------------------------------------------------------------------

class PatientIdentification : public ::google::protobuf::Message {
 public:
  PatientIdentification();
  virtual ~PatientIdentification();

  PatientIdentification(const PatientIdentification& from);

  inline PatientIdentification& operator=(const PatientIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatientIdentification& default_instance();

  void Swap(PatientIdentification* other);

  // implements Message ----------------------------------------------

  PatientIdentification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatientIdentification& from);
  void MergeFrom(const PatientIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string PatientId = 99401512;
  inline bool has_patientid() const;
  inline void clear_patientid();
  static const int kPatientIdFieldNumber = 99401512;
  inline const ::std::string& patientid() const;
  inline void set_patientid(const ::std::string& value);
  inline void set_patientid(const char* value);
  inline void set_patientid(const char* value, size_t size);
  inline ::std::string* mutable_patientid();
  inline ::std::string* release_patientid();
  inline void set_allocated_patientid(::std::string* patientid);

  // optional string PatientName = 358584250;
  inline bool has_patientname() const;
  inline void clear_patientname();
  static const int kPatientNameFieldNumber = 358584250;
  inline const ::std::string& patientname() const;
  inline void set_patientname(const ::std::string& value);
  inline void set_patientname(const char* value);
  inline void set_patientname(const char* value, size_t size);
  inline ::std::string* mutable_patientname();
  inline ::std::string* release_patientname();
  inline void set_allocated_patientname(::std::string* patientname);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.PatientIdentification)
 private:
  inline void set_has_patientid();
  inline void clear_has_patientid();
  inline void set_has_patientname();
  inline void clear_has_patientname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* patientid_;
  ::std::string* patientname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static PatientIdentification* default_instance_;
};
// -------------------------------------------------------------------

class QueryLicensesRequestMessage : public ::google::protobuf::Message {
 public:
  QueryLicensesRequestMessage();
  virtual ~QueryLicensesRequestMessage();

  QueryLicensesRequestMessage(const QueryLicensesRequestMessage& from);

  inline QueryLicensesRequestMessage& operator=(const QueryLicensesRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryLicensesRequestMessage& default_instance();

  void Swap(QueryLicensesRequestMessage* other);

  // implements Message ----------------------------------------------

  QueryLicensesRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryLicensesRequestMessage& from);
  void MergeFrom(const QueryLicensesRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string Options = 89608230;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 89608230;
  inline const ::std::string& options(int index) const;
  inline ::std::string* mutable_options(int index);
  inline void set_options(int index, const ::std::string& value);
  inline void set_options(int index, const char* value);
  inline void set_options(int index, const char* value, size_t size);
  inline ::std::string* add_options();
  inline void add_options(const ::std::string& value);
  inline void add_options(const char* value);
  inline void add_options(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.QueryLicensesRequestMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static QueryLicensesRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class QueryLicensesResponseMessage : public ::google::protobuf::Message {
 public:
  QueryLicensesResponseMessage();
  virtual ~QueryLicensesResponseMessage();

  QueryLicensesResponseMessage(const QueryLicensesResponseMessage& from);

  inline QueryLicensesResponseMessage& operator=(const QueryLicensesResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryLicensesResponseMessage& default_instance();

  void Swap(QueryLicensesResponseMessage* other);

  // implements Message ----------------------------------------------

  QueryLicensesResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryLicensesResponseMessage& from);
  void MergeFrom(const QueryLicensesResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // repeated .Philips.Pmsmr.CoreServices.IPluginInfraServices.LicenseInformation Licenses = 523968633;
  inline int licenses_size() const;
  inline void clear_licenses();
  static const int kLicensesFieldNumber = 523968633;
  inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation& licenses(int index) const;
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation* mutable_licenses(int index);
  inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation* add_licenses();
  inline const ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation >&
      licenses() const;
  inline ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation >*
      mutable_licenses();

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.QueryLicensesResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;
  ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation > licenses_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static QueryLicensesResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class QueryVersionRequestMessage : public ::google::protobuf::Message {
 public:
  QueryVersionRequestMessage();
  virtual ~QueryVersionRequestMessage();

  QueryVersionRequestMessage(const QueryVersionRequestMessage& from);

  inline QueryVersionRequestMessage& operator=(const QueryVersionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryVersionRequestMessage& default_instance();

  void Swap(QueryVersionRequestMessage* other);

  // implements Message ----------------------------------------------

  QueryVersionRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryVersionRequestMessage& from);
  void MergeFrom(const QueryVersionRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.QueryVersionRequestMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static QueryVersionRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class QueryVersionResponseMessage : public ::google::protobuf::Message {
 public:
  QueryVersionResponseMessage();
  virtual ~QueryVersionResponseMessage();

  QueryVersionResponseMessage(const QueryVersionResponseMessage& from);

  inline QueryVersionResponseMessage& operator=(const QueryVersionResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryVersionResponseMessage& default_instance();

  void Swap(QueryVersionResponseMessage* other);

  // implements Message ----------------------------------------------

  QueryVersionResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryVersionResponseMessage& from);
  void MergeFrom(const QueryVersionResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductModel = 362839330;
  inline bool has_productmodel() const;
  inline void clear_productmodel();
  static const int kProductModelFieldNumber = 362839330;
  inline const ::std::string& productmodel() const;
  inline void set_productmodel(const ::std::string& value);
  inline void set_productmodel(const char* value);
  inline void set_productmodel(const char* value, size_t size);
  inline ::std::string* mutable_productmodel();
  inline ::std::string* release_productmodel();
  inline void set_allocated_productmodel(::std::string* productmodel);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // optional string Version = 446269340;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 446269340;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string SystemType = 520367439;
  inline bool has_systemtype() const;
  inline void clear_systemtype();
  static const int kSystemTypeFieldNumber = 520367439;
  inline const ::std::string& systemtype() const;
  inline void set_systemtype(const ::std::string& value);
  inline void set_systemtype(const char* value);
  inline void set_systemtype(const char* value, size_t size);
  inline ::std::string* mutable_systemtype();
  inline ::std::string* release_systemtype();
  inline void set_allocated_systemtype(::std::string* systemtype);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.QueryVersionResponseMessage)
 private:
  inline void set_has_productmodel();
  inline void clear_has_productmodel();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_systemtype();
  inline void clear_has_systemtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* productmodel_;
  ::bcl::Guid* requesttoken_;
  ::std::string* version_;
  ::std::string* systemtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static QueryVersionResponseMessage* default_instance_;
};
// -------------------------------------------------------------------

class StoreInstanceRequestMessage : public ::google::protobuf::Message {
 public:
  StoreInstanceRequestMessage();
  virtual ~StoreInstanceRequestMessage();

  StoreInstanceRequestMessage(const StoreInstanceRequestMessage& from);

  inline StoreInstanceRequestMessage& operator=(const StoreInstanceRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreInstanceRequestMessage& default_instance();

  void Swap(StoreInstanceRequestMessage* other);

  // implements Message ----------------------------------------------

  StoreInstanceRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreInstanceRequestMessage& from);
  void MergeFrom(const StoreInstanceRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 IndexNumber = 71782239;
  inline bool has_indexnumber() const;
  inline void clear_indexnumber();
  static const int kIndexNumberFieldNumber = 71782239;
  inline ::google::protobuf::int32 indexnumber() const;
  inline void set_indexnumber(::google::protobuf::int32 value);

  // optional bytes DicomInstance = 223999527;
  inline bool has_dicominstance() const;
  inline void clear_dicominstance();
  static const int kDicomInstanceFieldNumber = 223999527;
  inline const ::std::string& dicominstance() const;
  inline void set_dicominstance(const ::std::string& value);
  inline void set_dicominstance(const char* value);
  inline void set_dicominstance(const void* value, size_t size);
  inline ::std::string* mutable_dicominstance();
  inline ::std::string* release_dicominstance();
  inline void set_allocated_dicominstance(::std::string* dicominstance);

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.StoreInstanceRequestMessage)
 private:
  inline void set_has_indexnumber();
  inline void clear_has_indexnumber();
  inline void set_has_dicominstance();
  inline void clear_has_dicominstance();
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dicominstance_;
  ::bcl::Guid* requesttoken_;
  ::google::protobuf::int32 indexnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static StoreInstanceRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class StoreInstanceResponseMessage : public ::google::protobuf::Message {
 public:
  StoreInstanceResponseMessage();
  virtual ~StoreInstanceResponseMessage();

  StoreInstanceResponseMessage(const StoreInstanceResponseMessage& from);

  inline StoreInstanceResponseMessage& operator=(const StoreInstanceResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreInstanceResponseMessage& default_instance();

  void Swap(StoreInstanceResponseMessage* other);

  // implements Message ----------------------------------------------

  StoreInstanceResponseMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreInstanceResponseMessage& from);
  void MergeFrom(const StoreInstanceResponseMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .bcl.Guid RequestToken = 401787910;
  inline bool has_requesttoken() const;
  inline void clear_requesttoken();
  static const int kRequestTokenFieldNumber = 401787910;
  inline const ::bcl::Guid& requesttoken() const;
  inline ::bcl::Guid* mutable_requesttoken();
  inline ::bcl::Guid* release_requesttoken();
  inline void set_allocated_requesttoken(::bcl::Guid* requesttoken);

  // @@protoc_insertion_point(class_scope:Philips.Pmsmr.CoreServices.IPluginInfraServices.StoreInstanceResponseMessage)
 private:
  inline void set_has_requesttoken();
  inline void clear_has_requesttoken();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::bcl::Guid* requesttoken_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_AssignDesc_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();
  friend void protobuf_ShutdownFile_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto();

  void InitAsDefaultInstance();
  static StoreInstanceResponseMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// AuditLogEntry

// optional string LocalUser = 189969938;
inline bool AuditLogEntry::has_localuser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuditLogEntry::set_has_localuser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuditLogEntry::clear_has_localuser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuditLogEntry::clear_localuser() {
  if (localuser_ != &::google::protobuf::internal::kEmptyString) {
    localuser_->clear();
  }
  clear_has_localuser();
}
inline const ::std::string& AuditLogEntry::localuser() const {
  return *localuser_;
}
inline void AuditLogEntry::set_localuser(const ::std::string& value) {
  set_has_localuser();
  if (localuser_ == &::google::protobuf::internal::kEmptyString) {
    localuser_ = new ::std::string;
  }
  localuser_->assign(value);
}
inline void AuditLogEntry::set_localuser(const char* value) {
  set_has_localuser();
  if (localuser_ == &::google::protobuf::internal::kEmptyString) {
    localuser_ = new ::std::string;
  }
  localuser_->assign(value);
}
inline void AuditLogEntry::set_localuser(const char* value, size_t size) {
  set_has_localuser();
  if (localuser_ == &::google::protobuf::internal::kEmptyString) {
    localuser_ = new ::std::string;
  }
  localuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_localuser() {
  set_has_localuser();
  if (localuser_ == &::google::protobuf::internal::kEmptyString) {
    localuser_ = new ::std::string;
  }
  return localuser_;
}
inline ::std::string* AuditLogEntry::release_localuser() {
  clear_has_localuser();
  if (localuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = localuser_;
    localuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_localuser(::std::string* localuser) {
  if (localuser_ != &::google::protobuf::internal::kEmptyString) {
    delete localuser_;
  }
  if (localuser) {
    set_has_localuser();
    localuser_ = localuser;
  } else {
    clear_has_localuser();
    localuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MediaId = 195662816;
inline bool AuditLogEntry::has_mediaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuditLogEntry::set_has_mediaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuditLogEntry::clear_has_mediaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuditLogEntry::clear_mediaid() {
  if (mediaid_ != &::google::protobuf::internal::kEmptyString) {
    mediaid_->clear();
  }
  clear_has_mediaid();
}
inline const ::std::string& AuditLogEntry::mediaid() const {
  return *mediaid_;
}
inline void AuditLogEntry::set_mediaid(const ::std::string& value) {
  set_has_mediaid();
  if (mediaid_ == &::google::protobuf::internal::kEmptyString) {
    mediaid_ = new ::std::string;
  }
  mediaid_->assign(value);
}
inline void AuditLogEntry::set_mediaid(const char* value) {
  set_has_mediaid();
  if (mediaid_ == &::google::protobuf::internal::kEmptyString) {
    mediaid_ = new ::std::string;
  }
  mediaid_->assign(value);
}
inline void AuditLogEntry::set_mediaid(const char* value, size_t size) {
  set_has_mediaid();
  if (mediaid_ == &::google::protobuf::internal::kEmptyString) {
    mediaid_ = new ::std::string;
  }
  mediaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_mediaid() {
  set_has_mediaid();
  if (mediaid_ == &::google::protobuf::internal::kEmptyString) {
    mediaid_ = new ::std::string;
  }
  return mediaid_;
}
inline ::std::string* AuditLogEntry::release_mediaid() {
  clear_has_mediaid();
  if (mediaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediaid_;
    mediaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_mediaid(::std::string* mediaid) {
  if (mediaid_ != &::google::protobuf::internal::kEmptyString) {
    delete mediaid_;
  }
  if (mediaid) {
    set_has_mediaid();
    mediaid_ = mediaid;
  } else {
    clear_has_mediaid();
    mediaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Cuid = 240968192;
inline bool AuditLogEntry::has_cuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuditLogEntry::set_has_cuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuditLogEntry::clear_has_cuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuditLogEntry::clear_cuid() {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    cuid_->clear();
  }
  clear_has_cuid();
}
inline const ::std::string& AuditLogEntry::cuid() const {
  return *cuid_;
}
inline void AuditLogEntry::set_cuid(const ::std::string& value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void AuditLogEntry::set_cuid(const char* value) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void AuditLogEntry::set_cuid(const char* value, size_t size) {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_cuid() {
  set_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}
inline ::std::string* AuditLogEntry::release_cuid() {
  clear_has_cuid();
  if (cuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cuid_;
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_cuid(::std::string* cuid) {
  if (cuid_ != &::google::protobuf::internal::kEmptyString) {
    delete cuid_;
  }
  if (cuid) {
    set_has_cuid();
    cuid_ = cuid;
  } else {
    clear_has_cuid();
    cuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditTrailActionType ObjectAction = 318973292;
inline bool AuditLogEntry::has_objectaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuditLogEntry::set_has_objectaction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuditLogEntry::clear_has_objectaction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuditLogEntry::clear_objectaction() {
  objectaction_ = 0;
  clear_has_objectaction();
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType AuditLogEntry::objectaction() const {
  return static_cast< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType >(objectaction_);
}
inline void AuditLogEntry::set_objectaction(::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType value) {
  assert(::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType_IsValid(value));
  set_has_objectaction();
  objectaction_ = value;
}

// optional string MediaType = 327435043;
inline bool AuditLogEntry::has_mediatype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuditLogEntry::set_has_mediatype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuditLogEntry::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuditLogEntry::clear_mediatype() {
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    mediatype_->clear();
  }
  clear_has_mediatype();
}
inline const ::std::string& AuditLogEntry::mediatype() const {
  return *mediatype_;
}
inline void AuditLogEntry::set_mediatype(const ::std::string& value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void AuditLogEntry::set_mediatype(const char* value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void AuditLogEntry::set_mediatype(const char* value, size_t size) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_mediatype() {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  return mediatype_;
}
inline ::std::string* AuditLogEntry::release_mediatype() {
  clear_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediatype_;
    mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_mediatype(::std::string* mediatype) {
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    delete mediatype_;
  }
  if (mediatype) {
    set_has_mediatype();
    mediatype_ = mediatype;
  } else {
    clear_has_mediatype();
    mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.PatientIdentification Patient = 358715586;
inline bool AuditLogEntry::has_patient() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AuditLogEntry::set_has_patient() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AuditLogEntry::clear_has_patient() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AuditLogEntry::clear_patient() {
  if (patient_ != NULL) patient_->::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification::Clear();
  clear_has_patient();
}
inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification& AuditLogEntry::patient() const {
  return patient_ != NULL ? *patient_ : *default_instance_->patient_;
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* AuditLogEntry::mutable_patient() {
  set_has_patient();
  if (patient_ == NULL) patient_ = new ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification;
  return patient_;
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* AuditLogEntry::release_patient() {
  clear_has_patient();
  ::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* temp = patient_;
  patient_ = NULL;
  return temp;
}
inline void AuditLogEntry::set_allocated_patient(::Philips::Pmsmr::CoreServices::IPluginInfraServices::PatientIdentification* patient) {
  delete patient_;
  patient_ = patient;
  if (patient) {
    set_has_patient();
  } else {
    clear_has_patient();
  }
}

// optional string IpAddress = 380234388;
inline bool AuditLogEntry::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AuditLogEntry::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AuditLogEntry::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AuditLogEntry::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& AuditLogEntry::ipaddress() const {
  return *ipaddress_;
}
inline void AuditLogEntry::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void AuditLogEntry::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void AuditLogEntry::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* AuditLogEntry::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ApplicationEntityTitle = 422344688;
inline bool AuditLogEntry::has_applicationentitytitle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AuditLogEntry::set_has_applicationentitytitle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AuditLogEntry::clear_has_applicationentitytitle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AuditLogEntry::clear_applicationentitytitle() {
  if (applicationentitytitle_ != &::google::protobuf::internal::kEmptyString) {
    applicationentitytitle_->clear();
  }
  clear_has_applicationentitytitle();
}
inline const ::std::string& AuditLogEntry::applicationentitytitle() const {
  return *applicationentitytitle_;
}
inline void AuditLogEntry::set_applicationentitytitle(const ::std::string& value) {
  set_has_applicationentitytitle();
  if (applicationentitytitle_ == &::google::protobuf::internal::kEmptyString) {
    applicationentitytitle_ = new ::std::string;
  }
  applicationentitytitle_->assign(value);
}
inline void AuditLogEntry::set_applicationentitytitle(const char* value) {
  set_has_applicationentitytitle();
  if (applicationentitytitle_ == &::google::protobuf::internal::kEmptyString) {
    applicationentitytitle_ = new ::std::string;
  }
  applicationentitytitle_->assign(value);
}
inline void AuditLogEntry::set_applicationentitytitle(const char* value, size_t size) {
  set_has_applicationentitytitle();
  if (applicationentitytitle_ == &::google::protobuf::internal::kEmptyString) {
    applicationentitytitle_ = new ::std::string;
  }
  applicationentitytitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_applicationentitytitle() {
  set_has_applicationentitytitle();
  if (applicationentitytitle_ == &::google::protobuf::internal::kEmptyString) {
    applicationentitytitle_ = new ::std::string;
  }
  return applicationentitytitle_;
}
inline ::std::string* AuditLogEntry::release_applicationentitytitle() {
  clear_has_applicationentitytitle();
  if (applicationentitytitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = applicationentitytitle_;
    applicationentitytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_applicationentitytitle(::std::string* applicationentitytitle) {
  if (applicationentitytitle_ != &::google::protobuf::internal::kEmptyString) {
    delete applicationentitytitle_;
  }
  if (applicationentitytitle) {
    set_has_applicationentitytitle();
    applicationentitytitle_ = applicationentitytitle;
  } else {
    clear_has_applicationentitytitle();
    applicationentitytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Suid = 446571201;
inline bool AuditLogEntry::has_suid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AuditLogEntry::set_has_suid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AuditLogEntry::clear_has_suid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AuditLogEntry::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& AuditLogEntry::suid() const {
  return *suid_;
}
inline void AuditLogEntry::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void AuditLogEntry::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void AuditLogEntry::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuditLogEntry::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* AuditLogEntry::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuditLogEntry::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 InstancesSent = 456452303;
inline bool AuditLogEntry::has_instancessent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AuditLogEntry::set_has_instancessent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AuditLogEntry::clear_has_instancessent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AuditLogEntry::clear_instancessent() {
  instancessent_ = 0;
  clear_has_instancessent();
}
inline ::google::protobuf::int32 AuditLogEntry::instancessent() const {
  return instancessent_;
}
inline void AuditLogEntry::set_instancessent(::google::protobuf::int32 value) {
  set_has_instancessent();
  instancessent_ = value;
}

// -------------------------------------------------------------------

// AuditLogEntryRequestMessage

// optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.AuditLogEntry AuditLog = 171435145;
inline bool AuditLogEntryRequestMessage::has_auditlog() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuditLogEntryRequestMessage::set_has_auditlog() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuditLogEntryRequestMessage::clear_has_auditlog() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuditLogEntryRequestMessage::clear_auditlog() {
  if (auditlog_ != NULL) auditlog_->::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry::Clear();
  clear_has_auditlog();
}
inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry& AuditLogEntryRequestMessage::auditlog() const {
  return auditlog_ != NULL ? *auditlog_ : *default_instance_->auditlog_;
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* AuditLogEntryRequestMessage::mutable_auditlog() {
  set_has_auditlog();
  if (auditlog_ == NULL) auditlog_ = new ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry;
  return auditlog_;
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* AuditLogEntryRequestMessage::release_auditlog() {
  clear_has_auditlog();
  ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* temp = auditlog_;
  auditlog_ = NULL;
  return temp;
}
inline void AuditLogEntryRequestMessage::set_allocated_auditlog(::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditLogEntry* auditlog) {
  delete auditlog_;
  auditlog_ = auditlog;
  if (auditlog) {
    set_has_auditlog();
  } else {
    clear_has_auditlog();
  }
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool AuditLogEntryRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuditLogEntryRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuditLogEntryRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuditLogEntryRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& AuditLogEntryRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* AuditLogEntryRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* AuditLogEntryRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void AuditLogEntryRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// AuditLogEntryResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool AuditLogEntryResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuditLogEntryResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuditLogEntryResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuditLogEntryResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& AuditLogEntryResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* AuditLogEntryResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* AuditLogEntryResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void AuditLogEntryResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// CreateNewSeriesRequestMessage

// optional string StudyUid = 32159375;
inline bool CreateNewSeriesRequestMessage::has_studyuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNewSeriesRequestMessage::set_has_studyuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNewSeriesRequestMessage::clear_has_studyuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNewSeriesRequestMessage::clear_studyuid() {
  if (studyuid_ != &::google::protobuf::internal::kEmptyString) {
    studyuid_->clear();
  }
  clear_has_studyuid();
}
inline const ::std::string& CreateNewSeriesRequestMessage::studyuid() const {
  return *studyuid_;
}
inline void CreateNewSeriesRequestMessage::set_studyuid(const ::std::string& value) {
  set_has_studyuid();
  if (studyuid_ == &::google::protobuf::internal::kEmptyString) {
    studyuid_ = new ::std::string;
  }
  studyuid_->assign(value);
}
inline void CreateNewSeriesRequestMessage::set_studyuid(const char* value) {
  set_has_studyuid();
  if (studyuid_ == &::google::protobuf::internal::kEmptyString) {
    studyuid_ = new ::std::string;
  }
  studyuid_->assign(value);
}
inline void CreateNewSeriesRequestMessage::set_studyuid(const char* value, size_t size) {
  set_has_studyuid();
  if (studyuid_ == &::google::protobuf::internal::kEmptyString) {
    studyuid_ = new ::std::string;
  }
  studyuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateNewSeriesRequestMessage::mutable_studyuid() {
  set_has_studyuid();
  if (studyuid_ == &::google::protobuf::internal::kEmptyString) {
    studyuid_ = new ::std::string;
  }
  return studyuid_;
}
inline ::std::string* CreateNewSeriesRequestMessage::release_studyuid() {
  clear_has_studyuid();
  if (studyuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = studyuid_;
    studyuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateNewSeriesRequestMessage::set_allocated_studyuid(::std::string* studyuid) {
  if (studyuid_ != &::google::protobuf::internal::kEmptyString) {
    delete studyuid_;
  }
  if (studyuid) {
    set_has_studyuid();
    studyuid_ = studyuid;
  } else {
    clear_has_studyuid();
    studyuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool CreateNewSeriesRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateNewSeriesRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateNewSeriesRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateNewSeriesRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& CreateNewSeriesRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* CreateNewSeriesRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* CreateNewSeriesRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void CreateNewSeriesRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// optional int32 TotalNumberOfInstances = 499099872;
inline bool CreateNewSeriesRequestMessage::has_totalnumberofinstances() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateNewSeriesRequestMessage::set_has_totalnumberofinstances() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateNewSeriesRequestMessage::clear_has_totalnumberofinstances() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateNewSeriesRequestMessage::clear_totalnumberofinstances() {
  totalnumberofinstances_ = 0;
  clear_has_totalnumberofinstances();
}
inline ::google::protobuf::int32 CreateNewSeriesRequestMessage::totalnumberofinstances() const {
  return totalnumberofinstances_;
}
inline void CreateNewSeriesRequestMessage::set_totalnumberofinstances(::google::protobuf::int32 value) {
  set_has_totalnumberofinstances();
  totalnumberofinstances_ = value;
}

// -------------------------------------------------------------------

// CreateNewSeriesResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool CreateNewSeriesResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNewSeriesResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNewSeriesResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNewSeriesResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& CreateNewSeriesResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* CreateNewSeriesResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* CreateNewSeriesResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void CreateNewSeriesResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// optional string SeriesUid = 455686289;
inline bool CreateNewSeriesResponseMessage::has_seriesuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateNewSeriesResponseMessage::set_has_seriesuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateNewSeriesResponseMessage::clear_has_seriesuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateNewSeriesResponseMessage::clear_seriesuid() {
  if (seriesuid_ != &::google::protobuf::internal::kEmptyString) {
    seriesuid_->clear();
  }
  clear_has_seriesuid();
}
inline const ::std::string& CreateNewSeriesResponseMessage::seriesuid() const {
  return *seriesuid_;
}
inline void CreateNewSeriesResponseMessage::set_seriesuid(const ::std::string& value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void CreateNewSeriesResponseMessage::set_seriesuid(const char* value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void CreateNewSeriesResponseMessage::set_seriesuid(const char* value, size_t size) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateNewSeriesResponseMessage::mutable_seriesuid() {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  return seriesuid_;
}
inline ::std::string* CreateNewSeriesResponseMessage::release_seriesuid() {
  clear_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesuid_;
    seriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateNewSeriesResponseMessage::set_allocated_seriesuid(::std::string* seriesuid) {
  if (seriesuid_ != &::google::protobuf::internal::kEmptyString) {
    delete seriesuid_;
  }
  if (seriesuid) {
    set_has_seriesuid();
    seriesuid_ = seriesuid;
  } else {
    clear_has_seriesuid();
    seriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FaultResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool FaultResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaultResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaultResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaultResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& FaultResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* FaultResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* FaultResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void FaultResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// optional string Description = 526552083;
inline bool FaultResponseMessage::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaultResponseMessage::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaultResponseMessage::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaultResponseMessage::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& FaultResponseMessage::description() const {
  return *description_;
}
inline void FaultResponseMessage::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void FaultResponseMessage::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void FaultResponseMessage::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FaultResponseMessage::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* FaultResponseMessage::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FaultResponseMessage::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetInstanceRequestMessage

// optional string SeriesRoid = 61223739;
inline bool GetInstanceRequestMessage::has_seriesroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInstanceRequestMessage::set_has_seriesroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInstanceRequestMessage::clear_has_seriesroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInstanceRequestMessage::clear_seriesroid() {
  if (seriesroid_ != &::google::protobuf::internal::kEmptyString) {
    seriesroid_->clear();
  }
  clear_has_seriesroid();
}
inline const ::std::string& GetInstanceRequestMessage::seriesroid() const {
  return *seriesroid_;
}
inline void GetInstanceRequestMessage::set_seriesroid(const ::std::string& value) {
  set_has_seriesroid();
  if (seriesroid_ == &::google::protobuf::internal::kEmptyString) {
    seriesroid_ = new ::std::string;
  }
  seriesroid_->assign(value);
}
inline void GetInstanceRequestMessage::set_seriesroid(const char* value) {
  set_has_seriesroid();
  if (seriesroid_ == &::google::protobuf::internal::kEmptyString) {
    seriesroid_ = new ::std::string;
  }
  seriesroid_->assign(value);
}
inline void GetInstanceRequestMessage::set_seriesroid(const char* value, size_t size) {
  set_has_seriesroid();
  if (seriesroid_ == &::google::protobuf::internal::kEmptyString) {
    seriesroid_ = new ::std::string;
  }
  seriesroid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetInstanceRequestMessage::mutable_seriesroid() {
  set_has_seriesroid();
  if (seriesroid_ == &::google::protobuf::internal::kEmptyString) {
    seriesroid_ = new ::std::string;
  }
  return seriesroid_;
}
inline ::std::string* GetInstanceRequestMessage::release_seriesroid() {
  clear_has_seriesroid();
  if (seriesroid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesroid_;
    seriesroid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetInstanceRequestMessage::set_allocated_seriesroid(::std::string* seriesroid) {
  if (seriesroid_ != &::google::protobuf::internal::kEmptyString) {
    delete seriesroid_;
  }
  if (seriesroid) {
    set_has_seriesroid();
    seriesroid_ = seriesroid;
  } else {
    clear_has_seriesroid();
    seriesroid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 IndexNumber = 71782239;
inline bool GetInstanceRequestMessage::has_indexnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetInstanceRequestMessage::set_has_indexnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetInstanceRequestMessage::clear_has_indexnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetInstanceRequestMessage::clear_indexnumber() {
  indexnumber_ = 0;
  clear_has_indexnumber();
}
inline ::google::protobuf::int32 GetInstanceRequestMessage::indexnumber() const {
  return indexnumber_;
}
inline void GetInstanceRequestMessage::set_indexnumber(::google::protobuf::int32 value) {
  set_has_indexnumber();
  indexnumber_ = value;
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool GetInstanceRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInstanceRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInstanceRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInstanceRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& GetInstanceRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* GetInstanceRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* GetInstanceRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void GetInstanceRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// GetInstanceResponseMessage

// optional bytes DicomInstance = 223999527;
inline bool GetInstanceResponseMessage::has_dicominstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInstanceResponseMessage::set_has_dicominstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInstanceResponseMessage::clear_has_dicominstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInstanceResponseMessage::clear_dicominstance() {
  if (dicominstance_ != &::google::protobuf::internal::kEmptyString) {
    dicominstance_->clear();
  }
  clear_has_dicominstance();
}
inline const ::std::string& GetInstanceResponseMessage::dicominstance() const {
  return *dicominstance_;
}
inline void GetInstanceResponseMessage::set_dicominstance(const ::std::string& value) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(value);
}
inline void GetInstanceResponseMessage::set_dicominstance(const char* value) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(value);
}
inline void GetInstanceResponseMessage::set_dicominstance(const void* value, size_t size) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetInstanceResponseMessage::mutable_dicominstance() {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  return dicominstance_;
}
inline ::std::string* GetInstanceResponseMessage::release_dicominstance() {
  clear_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dicominstance_;
    dicominstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetInstanceResponseMessage::set_allocated_dicominstance(::std::string* dicominstance) {
  if (dicominstance_ != &::google::protobuf::internal::kEmptyString) {
    delete dicominstance_;
  }
  if (dicominstance) {
    set_has_dicominstance();
    dicominstance_ = dicominstance;
  } else {
    clear_has_dicominstance();
    dicominstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool GetInstanceResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetInstanceResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetInstanceResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetInstanceResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& GetInstanceResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* GetInstanceResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* GetInstanceResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void GetInstanceResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// optional int32 TotalNumberOfInstances = 499099872;
inline bool GetInstanceResponseMessage::has_totalnumberofinstances() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInstanceResponseMessage::set_has_totalnumberofinstances() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInstanceResponseMessage::clear_has_totalnumberofinstances() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInstanceResponseMessage::clear_totalnumberofinstances() {
  totalnumberofinstances_ = 0;
  clear_has_totalnumberofinstances();
}
inline ::google::protobuf::int32 GetInstanceResponseMessage::totalnumberofinstances() const {
  return totalnumberofinstances_;
}
inline void GetInstanceResponseMessage::set_totalnumberofinstances(::google::protobuf::int32 value) {
  set_has_totalnumberofinstances();
  totalnumberofinstances_ = value;
}

// -------------------------------------------------------------------

// LicenseInformation

// optional bool ValidLicenseAvailable = 419454084;
inline bool LicenseInformation::has_validlicenseavailable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LicenseInformation::set_has_validlicenseavailable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LicenseInformation::clear_has_validlicenseavailable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LicenseInformation::clear_validlicenseavailable() {
  validlicenseavailable_ = false;
  clear_has_validlicenseavailable();
}
inline bool LicenseInformation::validlicenseavailable() const {
  return validlicenseavailable_;
}
inline void LicenseInformation::set_validlicenseavailable(bool value) {
  set_has_validlicenseavailable();
  validlicenseavailable_ = value;
}

// optional string Option = 527329630;
inline bool LicenseInformation::has_option() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LicenseInformation::set_has_option() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LicenseInformation::clear_has_option() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LicenseInformation::clear_option() {
  if (option_ != &::google::protobuf::internal::kEmptyString) {
    option_->clear();
  }
  clear_has_option();
}
inline const ::std::string& LicenseInformation::option() const {
  return *option_;
}
inline void LicenseInformation::set_option(const ::std::string& value) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void LicenseInformation::set_option(const char* value) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(value);
}
inline void LicenseInformation::set_option(const char* value, size_t size) {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  option_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LicenseInformation::mutable_option() {
  set_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    option_ = new ::std::string;
  }
  return option_;
}
inline ::std::string* LicenseInformation::release_option() {
  clear_has_option();
  if (option_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = option_;
    option_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LicenseInformation::set_allocated_option(::std::string* option) {
  if (option_ != &::google::protobuf::internal::kEmptyString) {
    delete option_;
  }
  if (option) {
    set_has_option();
    option_ = option;
  } else {
    clear_has_option();
    option_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogEntriesRequestMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool LogEntriesRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntriesRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntriesRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntriesRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& LogEntriesRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* LogEntriesRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* LogEntriesRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void LogEntriesRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// repeated .Philips.Pmsmr.CoreServices.IPluginInfraServices.LogEntry EntriesToBeLogged = 526924394;
inline int LogEntriesRequestMessage::entriestobelogged_size() const {
  return entriestobelogged_.size();
}
inline void LogEntriesRequestMessage::clear_entriestobelogged() {
  entriestobelogged_.Clear();
}
inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry& LogEntriesRequestMessage::entriestobelogged(int index) const {
  return entriestobelogged_.Get(index);
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry* LogEntriesRequestMessage::mutable_entriestobelogged(int index) {
  return entriestobelogged_.Mutable(index);
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry* LogEntriesRequestMessage::add_entriestobelogged() {
  return entriestobelogged_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry >&
LogEntriesRequestMessage::entriestobelogged() const {
  return entriestobelogged_;
}
inline ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LogEntry >*
LogEntriesRequestMessage::mutable_entriestobelogged() {
  return &entriestobelogged_;
}

// -------------------------------------------------------------------

// LogEntriesResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool LogEntriesResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntriesResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntriesResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntriesResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& LogEntriesResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* LogEntriesResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* LogEntriesResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void LogEntriesResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// LogEntry

// optional int32 OriginatorId = 1;
inline bool LogEntry::has_originatorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEntry::set_has_originatorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEntry::clear_has_originatorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEntry::clear_originatorid() {
  originatorid_ = 0;
  clear_has_originatorid();
}
inline ::google::protobuf::int32 LogEntry::originatorid() const {
  return originatorid_;
}
inline void LogEntry::set_originatorid(::google::protobuf::int32 value) {
  set_has_originatorid();
  originatorid_ = value;
}

// optional string EventId = 2;
inline bool LogEntry::has_eventid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEntry::set_has_eventid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEntry::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEntry::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& LogEntry::eventid() const {
  return *eventid_;
}
inline void LogEntry::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void LogEntry::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void LogEntry::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEntry::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* LogEntry::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEntry::set_allocated_eventid(::std::string* eventid) {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    delete eventid_;
  }
  if (eventid) {
    set_has_eventid();
    eventid_ = eventid;
  } else {
    clear_has_eventid();
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 TimeStamp = 3;
inline bool LogEntry::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEntry::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEntry::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEntry::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LogEntry::timestamp() const {
  return timestamp_;
}
inline void LogEntry::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string Description = 4;
inline bool LogEntry::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogEntry::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogEntry::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogEntry::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& LogEntry::description() const {
  return *description_;
}
inline void LogEntry::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LogEntry::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LogEntry::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEntry::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* LogEntry::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEntry::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string AdditionalInfo = 5;
inline bool LogEntry::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogEntry::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogEntry::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogEntry::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::kEmptyString) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& LogEntry::additionalinfo() const {
  return *additionalinfo_;
}
inline void LogEntry::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void LogEntry::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void LogEntry::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEntry::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  return additionalinfo_;
}
inline ::std::string* LogEntry::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEntry::set_allocated_additionalinfo(::std::string* additionalinfo) {
  if (additionalinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalinfo_;
  }
  if (additionalinfo) {
    set_has_additionalinfo();
    additionalinfo_ = additionalinfo;
  } else {
    clear_has_additionalinfo();
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.LoggingSeverityType Severity = 6;
inline bool LogEntry::has_severity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogEntry::set_has_severity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogEntry::clear_has_severity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogEntry::clear_severity() {
  severity_ = 0;
  clear_has_severity();
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType LogEntry::severity() const {
  return static_cast< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType >(severity_);
}
inline void LogEntry::set_severity(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType value) {
  assert(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType_IsValid(value));
  set_has_severity();
  severity_ = value;
}

// optional .Philips.Pmsmr.CoreServices.IPluginInfraServices.LoggingType Type = 7;
inline bool LogEntry::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogEntry::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType LogEntry::type() const {
  return static_cast< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType >(type_);
}
inline void LogEntry::set_type(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType value) {
  assert(::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PatientIdentification

// optional string PatientId = 99401512;
inline bool PatientIdentification::has_patientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatientIdentification::set_has_patientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatientIdentification::clear_has_patientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatientIdentification::clear_patientid() {
  if (patientid_ != &::google::protobuf::internal::kEmptyString) {
    patientid_->clear();
  }
  clear_has_patientid();
}
inline const ::std::string& PatientIdentification::patientid() const {
  return *patientid_;
}
inline void PatientIdentification::set_patientid(const ::std::string& value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void PatientIdentification::set_patientid(const char* value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void PatientIdentification::set_patientid(const char* value, size_t size) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PatientIdentification::mutable_patientid() {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  return patientid_;
}
inline ::std::string* PatientIdentification::release_patientid() {
  clear_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientid_;
    patientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PatientIdentification::set_allocated_patientid(::std::string* patientid) {
  if (patientid_ != &::google::protobuf::internal::kEmptyString) {
    delete patientid_;
  }
  if (patientid) {
    set_has_patientid();
    patientid_ = patientid;
  } else {
    clear_has_patientid();
    patientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PatientName = 358584250;
inline bool PatientIdentification::has_patientname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatientIdentification::set_has_patientname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatientIdentification::clear_has_patientname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatientIdentification::clear_patientname() {
  if (patientname_ != &::google::protobuf::internal::kEmptyString) {
    patientname_->clear();
  }
  clear_has_patientname();
}
inline const ::std::string& PatientIdentification::patientname() const {
  return *patientname_;
}
inline void PatientIdentification::set_patientname(const ::std::string& value) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(value);
}
inline void PatientIdentification::set_patientname(const char* value) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(value);
}
inline void PatientIdentification::set_patientname(const char* value, size_t size) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PatientIdentification::mutable_patientname() {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  return patientname_;
}
inline ::std::string* PatientIdentification::release_patientname() {
  clear_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientname_;
    patientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PatientIdentification::set_allocated_patientname(::std::string* patientname) {
  if (patientname_ != &::google::protobuf::internal::kEmptyString) {
    delete patientname_;
  }
  if (patientname) {
    set_has_patientname();
    patientname_ = patientname;
  } else {
    clear_has_patientname();
    patientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryLicensesRequestMessage

// repeated string Options = 89608230;
inline int QueryLicensesRequestMessage::options_size() const {
  return options_.size();
}
inline void QueryLicensesRequestMessage::clear_options() {
  options_.Clear();
}
inline const ::std::string& QueryLicensesRequestMessage::options(int index) const {
  return options_.Get(index);
}
inline ::std::string* QueryLicensesRequestMessage::mutable_options(int index) {
  return options_.Mutable(index);
}
inline void QueryLicensesRequestMessage::set_options(int index, const ::std::string& value) {
  options_.Mutable(index)->assign(value);
}
inline void QueryLicensesRequestMessage::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
}
inline void QueryLicensesRequestMessage::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryLicensesRequestMessage::add_options() {
  return options_.Add();
}
inline void QueryLicensesRequestMessage::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
}
inline void QueryLicensesRequestMessage::add_options(const char* value) {
  options_.Add()->assign(value);
}
inline void QueryLicensesRequestMessage::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QueryLicensesRequestMessage::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QueryLicensesRequestMessage::mutable_options() {
  return &options_;
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool QueryLicensesRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryLicensesRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryLicensesRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryLicensesRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& QueryLicensesRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* QueryLicensesRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* QueryLicensesRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void QueryLicensesRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// QueryLicensesResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool QueryLicensesResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryLicensesResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryLicensesResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryLicensesResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& QueryLicensesResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* QueryLicensesResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* QueryLicensesResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void QueryLicensesResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// repeated .Philips.Pmsmr.CoreServices.IPluginInfraServices.LicenseInformation Licenses = 523968633;
inline int QueryLicensesResponseMessage::licenses_size() const {
  return licenses_.size();
}
inline void QueryLicensesResponseMessage::clear_licenses() {
  licenses_.Clear();
}
inline const ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation& QueryLicensesResponseMessage::licenses(int index) const {
  return licenses_.Get(index);
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation* QueryLicensesResponseMessage::mutable_licenses(int index) {
  return licenses_.Mutable(index);
}
inline ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation* QueryLicensesResponseMessage::add_licenses() {
  return licenses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation >&
QueryLicensesResponseMessage::licenses() const {
  return licenses_;
}
inline ::google::protobuf::RepeatedPtrField< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LicenseInformation >*
QueryLicensesResponseMessage::mutable_licenses() {
  return &licenses_;
}

// -------------------------------------------------------------------

// QueryVersionRequestMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool QueryVersionRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryVersionRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryVersionRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryVersionRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& QueryVersionRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* QueryVersionRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* QueryVersionRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void QueryVersionRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// QueryVersionResponseMessage

// optional string ProductModel = 362839330;
inline bool QueryVersionResponseMessage::has_productmodel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryVersionResponseMessage::set_has_productmodel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryVersionResponseMessage::clear_has_productmodel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryVersionResponseMessage::clear_productmodel() {
  if (productmodel_ != &::google::protobuf::internal::kEmptyString) {
    productmodel_->clear();
  }
  clear_has_productmodel();
}
inline const ::std::string& QueryVersionResponseMessage::productmodel() const {
  return *productmodel_;
}
inline void QueryVersionResponseMessage::set_productmodel(const ::std::string& value) {
  set_has_productmodel();
  if (productmodel_ == &::google::protobuf::internal::kEmptyString) {
    productmodel_ = new ::std::string;
  }
  productmodel_->assign(value);
}
inline void QueryVersionResponseMessage::set_productmodel(const char* value) {
  set_has_productmodel();
  if (productmodel_ == &::google::protobuf::internal::kEmptyString) {
    productmodel_ = new ::std::string;
  }
  productmodel_->assign(value);
}
inline void QueryVersionResponseMessage::set_productmodel(const char* value, size_t size) {
  set_has_productmodel();
  if (productmodel_ == &::google::protobuf::internal::kEmptyString) {
    productmodel_ = new ::std::string;
  }
  productmodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryVersionResponseMessage::mutable_productmodel() {
  set_has_productmodel();
  if (productmodel_ == &::google::protobuf::internal::kEmptyString) {
    productmodel_ = new ::std::string;
  }
  return productmodel_;
}
inline ::std::string* QueryVersionResponseMessage::release_productmodel() {
  clear_has_productmodel();
  if (productmodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productmodel_;
    productmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryVersionResponseMessage::set_allocated_productmodel(::std::string* productmodel) {
  if (productmodel_ != &::google::protobuf::internal::kEmptyString) {
    delete productmodel_;
  }
  if (productmodel) {
    set_has_productmodel();
    productmodel_ = productmodel;
  } else {
    clear_has_productmodel();
    productmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool QueryVersionResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryVersionResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryVersionResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryVersionResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& QueryVersionResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* QueryVersionResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* QueryVersionResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void QueryVersionResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// optional string Version = 446269340;
inline bool QueryVersionResponseMessage::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryVersionResponseMessage::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryVersionResponseMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryVersionResponseMessage::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& QueryVersionResponseMessage::version() const {
  return *version_;
}
inline void QueryVersionResponseMessage::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryVersionResponseMessage::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryVersionResponseMessage::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryVersionResponseMessage::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* QueryVersionResponseMessage::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryVersionResponseMessage::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SystemType = 520367439;
inline bool QueryVersionResponseMessage::has_systemtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryVersionResponseMessage::set_has_systemtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryVersionResponseMessage::clear_has_systemtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryVersionResponseMessage::clear_systemtype() {
  if (systemtype_ != &::google::protobuf::internal::kEmptyString) {
    systemtype_->clear();
  }
  clear_has_systemtype();
}
inline const ::std::string& QueryVersionResponseMessage::systemtype() const {
  return *systemtype_;
}
inline void QueryVersionResponseMessage::set_systemtype(const ::std::string& value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
}
inline void QueryVersionResponseMessage::set_systemtype(const char* value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
}
inline void QueryVersionResponseMessage::set_systemtype(const char* value, size_t size) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryVersionResponseMessage::mutable_systemtype() {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  return systemtype_;
}
inline ::std::string* QueryVersionResponseMessage::release_systemtype() {
  clear_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemtype_;
    systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryVersionResponseMessage::set_allocated_systemtype(::std::string* systemtype) {
  if (systemtype_ != &::google::protobuf::internal::kEmptyString) {
    delete systemtype_;
  }
  if (systemtype) {
    set_has_systemtype();
    systemtype_ = systemtype;
  } else {
    clear_has_systemtype();
    systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StoreInstanceRequestMessage

// optional int32 IndexNumber = 71782239;
inline bool StoreInstanceRequestMessage::has_indexnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreInstanceRequestMessage::set_has_indexnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreInstanceRequestMessage::clear_has_indexnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreInstanceRequestMessage::clear_indexnumber() {
  indexnumber_ = 0;
  clear_has_indexnumber();
}
inline ::google::protobuf::int32 StoreInstanceRequestMessage::indexnumber() const {
  return indexnumber_;
}
inline void StoreInstanceRequestMessage::set_indexnumber(::google::protobuf::int32 value) {
  set_has_indexnumber();
  indexnumber_ = value;
}

// optional bytes DicomInstance = 223999527;
inline bool StoreInstanceRequestMessage::has_dicominstance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreInstanceRequestMessage::set_has_dicominstance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreInstanceRequestMessage::clear_has_dicominstance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreInstanceRequestMessage::clear_dicominstance() {
  if (dicominstance_ != &::google::protobuf::internal::kEmptyString) {
    dicominstance_->clear();
  }
  clear_has_dicominstance();
}
inline const ::std::string& StoreInstanceRequestMessage::dicominstance() const {
  return *dicominstance_;
}
inline void StoreInstanceRequestMessage::set_dicominstance(const ::std::string& value) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(value);
}
inline void StoreInstanceRequestMessage::set_dicominstance(const char* value) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(value);
}
inline void StoreInstanceRequestMessage::set_dicominstance(const void* value, size_t size) {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  dicominstance_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreInstanceRequestMessage::mutable_dicominstance() {
  set_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    dicominstance_ = new ::std::string;
  }
  return dicominstance_;
}
inline ::std::string* StoreInstanceRequestMessage::release_dicominstance() {
  clear_has_dicominstance();
  if (dicominstance_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dicominstance_;
    dicominstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StoreInstanceRequestMessage::set_allocated_dicominstance(::std::string* dicominstance) {
  if (dicominstance_ != &::google::protobuf::internal::kEmptyString) {
    delete dicominstance_;
  }
  if (dicominstance) {
    set_has_dicominstance();
    dicominstance_ = dicominstance;
  } else {
    clear_has_dicominstance();
    dicominstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .bcl.Guid RequestToken = 401787910;
inline bool StoreInstanceRequestMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreInstanceRequestMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreInstanceRequestMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreInstanceRequestMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& StoreInstanceRequestMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* StoreInstanceRequestMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* StoreInstanceRequestMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void StoreInstanceRequestMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}

// -------------------------------------------------------------------

// StoreInstanceResponseMessage

// optional .bcl.Guid RequestToken = 401787910;
inline bool StoreInstanceResponseMessage::has_requesttoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreInstanceResponseMessage::set_has_requesttoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreInstanceResponseMessage::clear_has_requesttoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreInstanceResponseMessage::clear_requesttoken() {
  if (requesttoken_ != NULL) requesttoken_->::bcl::Guid::Clear();
  clear_has_requesttoken();
}
inline const ::bcl::Guid& StoreInstanceResponseMessage::requesttoken() const {
  return requesttoken_ != NULL ? *requesttoken_ : *default_instance_->requesttoken_;
}
inline ::bcl::Guid* StoreInstanceResponseMessage::mutable_requesttoken() {
  set_has_requesttoken();
  if (requesttoken_ == NULL) requesttoken_ = new ::bcl::Guid;
  return requesttoken_;
}
inline ::bcl::Guid* StoreInstanceResponseMessage::release_requesttoken() {
  clear_has_requesttoken();
  ::bcl::Guid* temp = requesttoken_;
  requesttoken_ = NULL;
  return temp;
}
inline void StoreInstanceResponseMessage::set_allocated_requesttoken(::bcl::Guid* requesttoken) {
  delete requesttoken_;
  requesttoken_ = requesttoken;
  if (requesttoken) {
    set_has_requesttoken();
  } else {
    clear_has_requesttoken();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace IPluginInfraServices
}  // namespace CoreServices
}  // namespace Pmsmr
}  // namespace Philips

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::MessageId>() {
  return ::Philips::Pmsmr::CoreServices::IPluginInfraServices::MessageId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType>() {
  return ::Philips::Pmsmr::CoreServices::IPluginInfraServices::AuditTrailActionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType>() {
  return ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingSeverityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType>() {
  return ::Philips::Pmsmr::CoreServices::IPluginInfraServices::LoggingType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Philips_2ePmsmr_2eCoreServices_2eIPluginInfraServices_2eproto__INCLUDED
